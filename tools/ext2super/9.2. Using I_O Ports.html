<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>9.2. Using I/O Ports</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<head>
<link rel="stylesheet" type="text/css" href="../style/visited-green.css">
</head>
<!-- <script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script> -->
<head>
	<link rel="shortcut icon" href="/common/cur.ico">
	<link rel="stylesheet" href="/style/style.css">
    <link rel="stylesheet" type="text/css" href="/page/borders.css" />
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
</head>
<script type="text/javascript">

function param(a)
{
	if( document.location.search == "" ) return "";
	var pairs = location.search.split('?')[1].split('&');
	var p = new Array;
	for (var i=0; i < pairs.length; i++) {
		var item = pairs[i].split("=");
		p[item[0]]=unescape(item[1]);
	}
	return p[a];
}

var test="";

function hostname_set(h)
{
	if ( document.location.hostname.indexOf("homelinux"+test) >= 0 ) return 0;
	if ( param("loc") == "keep" ) return 0;
	if ( document.location.hostname.indexOf(h) == -1 ) {
		var n = document.location.href;
		n = n.replace(document.location.hostname,"www."+h);
		n = n.replace(".shtml","");
		//document.location.protocol + document.location.port+h document.location.pathname+ document.location.hash+ document.location.search;
		//alert(document.location.hostname + " " + n);
		document.location.replace(n);
		return 1;
	}
}

function location_fix(world)
{
	//test="test";
	//alert(param("loc"));
	if ( document.location.href.indexOf(".shtml") > 0 ) {
		var n = document.location.href;
		n = n.replace(".shtml","");
		document.location.replace(n);
	}
	if ( param("test") == "hostname_set" ) {
		hostname_set("makelinux.com");
	}
	if ( document.location.hostname.indexOf("homelinux"+test) == -1 ) {
		if ( geoip_country_code()=="IL"+test ) { 
			return hostname_set("makelinux.co.il")
		} else { return hostname_set(world); }
	}
	return 0;
}
//document.location.hostname = "www.makelinux.co.il"
//window.location = document.location.replace(document.location.hostname,world);
// top.location = "resources";
// window.location =
</script>
<script type="text/javascript">

	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-839593-1']);
	_gaq.push(['_setDomainName', 'none']);
	_gaq.push(['_setAllowLinker', true]);
	_gaq.push(['_trackPageview']);

	(function() {
	 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	 })();

</script>

<div align=center>
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<!--   #include virtual="../kernel_map/banner.shtml" -->
<div align=center>
<table width=100% height=90>
	<tr style='display:none'>
		<td xalign=center style="background-image:url(/kernel_map/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
			cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
	</td> </tr>
	<tr style='display:none'>
		<td style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
			<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
				<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
			</a>
		</td> 
	</tr>
	<tr style='display:none' id='banner-0' >
		<td align=center /> 
		</td>
	</tr>
	<tr style='display:none' id='banner-1' >
		<td align=center /> 
<!-- google.html --> 
<script type="text/javascript"><!--
	google_ad_client = "ca-pub-5656623102424572";
	/* 728x90, created 4/4/08 */
	google_ad_slot = "6613964975";
	google_ad_width = 728;
	google_ad_height = 90;
	//-->
</script>
<!--
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
-->
<!-- / google.html --> 

<script type="text/javascript"
	src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

		</td>
	</tr>
	<tr style='display:' id='banner-2' >
		<td align=center /> 
			<a href=http://www.makelinux.net/kernel_map/><b>Linux kernel map in printable PDF</b> for $4 or â‚¬3</a>
		</td>
	</tr>
</table>
</div>
<script type="text/javascript">
	// var a = new Array();
	// a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
	// a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';

	//var banner = document.getElementById('banner-'+Math.floor(Math.random()*(5+1)));
	var banner = document.getElementById('banner-2');
	banner.style.display='';
	if ( 0 ) { 
		document.write("<center>");
		if (  geoip_country_code()=="IL" ) {
			if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
		} else { 
			if ( Math.random() > 0.5 ) {
				if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
			} else {
			}
		}
		document.write("</center>");
	}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

</div>
<!-- 
Hi surfer
<script type="text/javascript"> 
	try {
	document.write(" from <i><b>" + geoip_city()+"</b></i>"); 
	} catch (e) {
	}
</script>, please visit -->


<xhr>
<script type="text/javascript">
	s = document.location.href.lastIndexOf("/");
	a = document.location.href.substring(0,s+1);
	b = document.location.href.substring(s+1);
if ( document.location == top.location  ) {
	//alert(a + " -- " + b);
	document.write("<a href=" + a + "?u=" +b + "> &lt; open Table of Content</a>");
	//top.location = a + "?u=" +b;
} else {
	document.write("<a target=_top href=" +document.location + "> &lt; full page </a>");
}
function addLoadEvent(func) 
{
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

addLoadEvent(  function() { 
		try {
		} catch (e) {
	}
}
);


</script>
<!-- <script src="../common/searchhi.js" type="text/javascript"></script> -->
<span style='display:none;background:#BBFFFF;color:black;position:absolute;right:0;' ><a target=_main href=http://www.makelinux.net/kernel_map?src=ldd3>&nbsp;Linux kernel map&nbsp;</a></span><br>


<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-9-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="." target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-9-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="chp-9-sect-2"></a>
<h3 class="docSection1Title">9.2. Using I/O Ports</h3>

<p class="docText">I/O ports are the means by which drivers communicate with many
devices, at least part of the time. This section covers the various
functions available for making use of I/O ports; we also touch on
some portability issues.</p>

<a name="chp-9-sect-2.1"></a>
<h4 class="docSection2Title">9.2.1. I/O Port Allocation</h4>

<p class="docText">As you might expect, you
<a name="chp-9-ITERM-5878"></a>should not go off and
start pounding on I/O ports without first ensuring that you have
exclusive access to those ports. The kernel provides a registration
interface that allows your driver to claim the ports it needs. The
core function in that interface is
<span class="docEmphasis">request_region</span>:</p>

<pre>#include &lt;linux/ioport.h&gt;
struct resource *request_region(unsigned long first, unsigned long n, 
                                const char *name);</pre><br>


<p class="docText">This function tells the kernel that you would like to make use of
<tt>n</tt> ports, starting with <tt>first</tt>.
The <tt>name</tt> parameter should be the name of your
device. The return value is non-<tt>NULL</tt> if the
allocation succeeds. If you get <tt>NULL</tt> back from
<span class="docEmphasis">request_region</span>, you will not be able to use the
desired ports.</p>

<p class="docText">All port allocations show up in <i>/proc/ioports</i>.
If you are unable to allocate a needed set of ports, that is the
place to look to see who got there first.</p>

<p class="docText">When you are done with a set of I/O ports (at module unload time,
perhaps), they should be returned to the system with:</p>

<pre>void release_region(unsigned long start, unsigned long n);</pre><BR>


<p class="docText">There is also a function that allows your driver to check to see
whether a given set of I/O ports is available:</p>

<pre>int check_region(unsigned long first, unsigned long n);</pre><BR>


<p class="docText">Here, the return value is a negative error code if the given ports
are not available. This function is deprecated because its return
value provides no guarantee of whether an allocation would succeed;
checking and later allocating are not an atomic operation. We list it
here because several drivers are still using it, but you should
always use <span class="docEmphasis">request_region</span>, which performs the
required locking to ensure that the allocation is done in a safe,
atomic manner.</P>


<a name="chp-9-sect-2.2"></a>
<h4 class="docSection2Title">9.2.2. Manipulating I/O ports</h4>

<p class="docText"><a name="chp-9-ITERM-5879"></a>
<a name="chp-9-ITERM-5880"></a>
<a name="chp-9-ITERM-5881"></a><a name="chp-9-ITERM-5882"></a><a name="chp-9-ITERM-5883"></a><a name="chp-9-ITERM-5884"></a>After a driver has requested the range of
I/O ports it needs to use in its activities, it must read and/or
write to those ports. To this end, most hardware differentiates
between 8-bit, 16-bit, and 32-bit ports. Usually you
can't mix them like you normally do with system
memory access.<sup class="docFootnote"><a class="docLink" href="chp-9-sect-2.shtml#chp-9-FNOTE-2">[2]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="chp-9-FNOTE-2">[2]</a></sup> Sometimes I/O ports are arranged like
memory, and you can (for example) bind two 8-bit writes into a single
16-bit operation. This applies, for instance, to PC video boards. But
generally, you can't count on this feature.</P></blockquote>

<p class="docText">A C program, therefore, must call different functions to access
different size ports. As suggested in the previous section, computer
architectures that support only memory-mapped I/O registers fake port
I/O by remapping port addresses to memory addresses, and the kernel
hides the details from the driver in order to ease portability. The
Linux kernel headers (specifically, the architecture-dependent header
<i>&lt;asm/io.h&gt;</I>) define the following inline
functions to access I/O ports:</P>

<a name="chp-9-ITERM-5885"></a><a name="chp-9-ITERM-5886"></a><a name="chp-9-ITERM-5887"></a><a name="chp-9-ITERM-5888"></a><a name="chp-9-ITERM-5889"></a><a name="chp-9-ITERM-5890"></a><a name="chp-9-ITERM-5891"></a><a name="chp-9-ITERM-5892"></a><a name="chp-9-ITERM-5893"></a><a name="chp-9-ITERM-5894"></a><a name="chp-9-ITERM-5895"></a><a name="chp-9-ITERM-5896"></a><a name="chp-9-ITERM-5897"></a><a name="chp-9-ITERM-5898"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned inb(unsigned port);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void outb(unsigned char byte, unsigned port);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-9-ITERM-5885"></a>
<a name="chp-9-ITERM-5886"></a><a name="chp-9-ITERM-5887"></a>
<a name="chp-9-ITERM-5888"></a><a name="chp-9-ITERM-5889"></a>Read
or write byte ports (eight bits wide). The <tt>port</tt>
argument is defined as <tt>unsigned long</tt> for some
platforms and <tt>unsigned short</tt> for others. The
return type of <span class="docEmphasis">inb</span> is also different across
architectures.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned inw(unsigned port);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void outw(unsigned short word, unsigned port);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-9-ITERM-5890"></a>
<a name="chp-9-ITERM-5891"></a><a name="chp-9-ITERM-5892"></a>
<a name="chp-9-ITERM-5893"></a>These
functions access 16-bit ports (one word wide); they are not available
when compiling for the S390 platform, which supports only byte I/O.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">unsigned inl(unsigned port);</span></span></span></dt></p>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void outl(unsigned longword, unsigned port);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-9-ITERM-5894"></a>
<a name="chp-9-ITERM-5895"></a><a name="chp-9-ITERM-5896"></a>
<a name="chp-9-ITERM-5897"></a><a name="chp-9-ITERM-5898"></a>These
functions access 32-bit ports. <tt>longword</tt> is
declared as either <tt>unsigned long</tt> or
<tt>unsigned</tt> <tt>int</tt>, according to the
platform. Like word I/O, "long" I/O
is not available on S390.</p>
</dd>
</dl>

<a name="chp-9-NOTE-21"></a><P><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><TD><table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr><td width="60" valign="top"><img src="images/tip_yellow.gif" width="50" height="54" alt=""></td><td valign="top">
</td></tr></table></td></tr></table></p>

<p><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><td><table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr><TD width="60" valign="top"><img src="images/tip_yellow.gif" width="50" height="54" alt=""></td><TD valign="top">
<p class="docText"><a name="chp-9-ITERM-5899"></a>From now on,
when we use <tt>unsigned</tt> without further type
specifications, we are referring to an architecture-dependent
definition whose exact nature is not relevant. The functions are
almost always portable, because the compiler automatically casts the
values during assignmentâ€”their being unsigned helps prevent
compile-time warnings. No information is lost with such casts as long
as the programmer assigns sensible values to avoid overflow. We stick
to this convention of "incomplete
typing" throughout this chapter.</P>
</td></tr></table></td></TR></table></p><BR>

<p class="docText">Note that no 64-bit port I/O operations are defined. Even on 64-bit
architectures, the port address space uses a 32-bit (maximum) data
path.</P>


<a name="chp-9-sect-2.3"></a>
<H4 class="docSection2Title">9.2.3. I/O Port Access from User Space</h4>

<p class="docText">The functions just described are <a name="chp-9-ITERM-5900"></a>
<a name="chp-9-ITERM-5901"></a>primarily
meant to be used by device drivers, but they can also be used from
user space, at least on PC-class computers. The GNU C library defines
them in <i>&lt;sys/io.h&gt;</i>. The following
conditions should apply in order for <span class="docEmphasis">inb</span> and
friends to be used in user-space code:</p>

<UL><LI><p class="docList">The program must be compiled with the <span class="docEmphasis">-O</span> option
to force expansion of inline functions.</P></li><LI><p class="docList">The <span class="docEmphasis">ioperm</span> or <span class="docEmphasis">iopl</span> system
calls must be used to get permission to perform I/O operations on
ports. <span class="docEmphasis">ioperm</span> gets permission for individual
ports, while <span class="docEmphasis">iopl</span> gets permission for the entire
I/O space. Both of these functions are x86-specific.</P></li><li><p class="docList">The program must run as root to invoke <span class="docEmphasis">ioperm</span> or
<span class="docEmphasis">iopl</span>.<sup class="docFootnote"><a class="docLink" href="chp-9-sect-2.shtml#chp-9-FNOTE-3">[3]</a></sup>
Alternatively, one of its ancestors must have gained port access
running as root.</p><blockquote><p class="docFootnote"><sup><a name="chp-9-FNOTE-3">[3]</a></sup> Technically, it must have
the <tt>CAP_SYS_RAWIO</tt> capability, but that is the same
as running as root on most current systems.</p></blockquote></LI></ul>
<p class="docText">If the host platform has no <span class="docEmphasis">ioperm</span> and no
<span class="docEmphasis">iopl</span> system calls, user space can still access
I/O ports by using the <i>/dev/port</I> device file.
Note, however, that the meaning of the file is very platform-specific
and not likely useful for anything but the PC.</p>

<p class="docText">The sample sources <i>misc-progs/inp.c</I> and
<i>misc-progs/outp.c</I> are a minimal tool for reading
and writing ports from the command line, in user space. They expect
to be installed under multiple names (e.g., <i>inb</i>,
<i>inw</i>, and <i>inl</i> and
manipulates byte, word, or long ports depending on which name was
invoked by the user). They use <span class="docEmphasis">ioperm</span> or
<span class="docEmphasis">iopl</span> under x86, <i>/dev/port</i>
on other platforms.</p>

<p class="docText">The programs can be made setuid root, if you want to live dangerously
and play with your hardware without acquiring explicit privileges.
Please do not install them setuid on a production system, however;
they are a security hole by design.</p>


<a name="chp-9-sect-2.4"></a>
<h4 class="docSection2Title">9.2.4. String Operations</h4>

<p class="docText"><a name="chp-9-ITERM-5902"></a>
<a name="chp-9-ITERM-5903"></a>
<a name="chp-9-ITERM-5904"></a><a name="chp-9-ITERM-5905"></a><a name="chp-9-ITERM-5906"></a>In addition to the single-shot
in and out operations, some processors implement special instructions
to transfer a sequence of bytes, words, or longs to and from a single
I/O port or the same size. These are the so-called <span class="docEmphasis">string
instructions</span>, and they perform the task more quickly than
a C-language loop can do. The following macros implement the concept
of string I/O either by using a single machine instruction or by
executing a tight loop if the target processor has no instruction
that performs string I/O. The macros are not defined at all when
compiling for the S390 platform. This should not be a portability
problem, since this platform doesn't usually share
device drivers with other platforms, because its peripheral buses are
different.</p>

<p class="docText">The prototypes for string functions are:</P>

<a name="chp-9-ITERM-5907"></a><a name="chp-9-ITERM-5908"></a><a name="chp-9-ITERM-5909"></a><a name="chp-9-ITERM-5910"></a><a name="chp-9-ITERM-5911"></a><a name="chp-9-ITERM-5912"></a><a name="chp-9-ITERM-5913"></a><a name="chp-9-ITERM-5914"></a><a name="chp-9-ITERM-5915"></a><a name="chp-9-ITERM-5916"></a><a name="chp-9-ITERM-5917"></a><a name="chp-9-ITERM-5918"></a><a name="chp-9-ITERM-5919"></a><a name="chp-9-ITERM-5920"></a><a name="chp-9-ITERM-5921"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void insb(unsigned port, void *addr, unsigned long count);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void outsb(unsigned port, void *addr, unsigned long count);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-9-ITERM-5907"></a>
<a name="chp-9-ITERM-5908"></a><a name="chp-9-ITERM-5909"></a>
<a name="chp-9-ITERM-5910"></a><a name="chp-9-ITERM-5911"></a>Read or write <tt>count</tt>
bytes starting at the memory address <tt>addr</tt>. Data is
read from or written to the single port <tt>port</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void insw(unsigned port, void *addr, unsigned long count);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void outsw(unsigned port, void *addr, unsigned long count);</span></span></span></dt></p>
<dd>
<p class="docList"><a name="chp-9-ITERM-5912"></a>
<a name="chp-9-ITERM-5913"></a><a name="chp-9-ITERM-5914"></a>
<a name="chp-9-ITERM-5915"></a><a name="chp-9-ITERM-5916"></a>Read or write 16-bit values to a single
16-bit port.</p>
</dd>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void insl(unsigned port, void *addr, unsigned long count);</span></span></span></dt></P>
<dt><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">void outsl(unsigned port, void *addr, unsigned long count);</span></span></span></dt></P>
<dd>
<p class="docList"><a name="chp-9-ITERM-5917"></a>
<a name="chp-9-ITERM-5918"></a><a name="chp-9-ITERM-5919"></a>
<a name="chp-9-ITERM-5920"></a><a name="chp-9-ITERM-5921"></a>Read or write 32-bit values to a single
32-bit port.</P>
</dd>
</dl>

<p class="docText">There is one thing to keep in mind when using the string functions:
they move a straight byte stream to or from the port. When the port
and the host system have different byte ordering rules, the results
can be surprising. Reading a port with <span class="docEmphasis">inw</span> swaps
the bytes, if need be, to make the value read match the host
ordering. The string functions, instead, do not perform this
swapping.</p>


<a name="chp-9-sect-2.5"></a>
<h4 class="docSection2Title">9.2.5. Pausing I/O</h4>

<p class="docText"><a name="chp-9-ITERM-5922"></a>
<a name="chp-9-ITERM-5923"></a><a name="chp-9-ITERM-5924"></a><a name="chp-9-ITERM-5925"></a>
<a name="chp-9-ITERM-5926"></a><a name="chp-9-ITERM-5927"></a>
<a name="chp-9-ITERM-5928"></a><a name="chp-9-ITERM-5929"></a>Some platformsâ€”most
notably the i386â€”can have problems when the processor tries to
transfer data too quickly to or from the bus. The problems can arise
when the processor is overclocked with respect to the peripheral bus
(think ISA here) and can show up when the device board is too slow.
The solution is to insert a small delay after each I/O instruction if
another such instruction follows. On the x86, the pause is achieved
by performing an <tt>out</tt> <tt>b</tt>
instruction to port 0x80 (normally but not always unused), or by busy
waiting. See the <span class="docEmphasis">io.h</span> file under your
platform's <span class="docEmphasis">asm</span> subdirectory for
details.</p>

<p class="docText">If your device misses some data, or if you fear it might miss some,
you can use pausing functions in place of the normal ones. The
pausing functions are exactly like those listed previously, but their
names end in <span class="docEmphasis">_p</span>; they are called
<span class="docEmphasis">inb_p</span>, <span class="docEmphasis">outb_p</span>, and so on.
The functions are defined for most supported architectures, although
they often expand to the same code as nonpausing I/O, because there
is no need for the extra pause if the architecture runs with a
reasonably modern peripheral bus.</P>


<a name="chp-9-sect-2.6"></a>
<h4 class="docSection2Title">9.2.6. Platform Dependencies</h4>

<p class="docText"><a name="chp-9-ITERM-5930"></a><a name="chp-9-ITERM-5931"></a><a name="chp-9-ITERM-5932"></a><a name="chp-9-ITERM-5933"></a>I/O instructions are, by their
nature, highly processor dependent. Because they work with the
details of how the processor handles moving data in and out, it is
very hard to hide the differences between systems. As a consequence,
much of the source code related to port I/O is platform-dependent.</P>

<p class="docText">You can see one of the incompatibilities, data typing, by looking
back at the list of functions, where the arguments are typed
differently based on the architectural differences between platforms.
For example, a port is <tt>unsigned short</tt> on the x86
(where the processor supports a 64-KB I/O space), but
<tt>unsigned long</tt> on other platforms, whose ports are
just special locations in the same address space as memory.</p>

<p class="docText">Other platform dependencies arise from basic structural differences
in the processors and are, therefore, unavoidable. We
won't go into detail about the differences, because
we assume that you won't be writing a device driver
for a particular system without understanding the underlying
hardware. Instead, here is an overview of the capabilities of the
architectures supported by the kernel:</p>

<a name="chp-9-ITERM-5934"></a><a name="chp-9-ITERM-5935"></a><a name="chp-9-ITERM-5936"></a><a name="chp-9-ITERM-5937"></a><a name="chp-9-ITERM-5938"></a><a name="chp-9-ITERM-5939"></a><a name="chp-9-ITERM-5940"></a><a name="chp-9-ITERM-5941"></a><a name="chp-9-ITERM-5942"></a><a name="chp-9-ITERM-5943"></a><a name="chp-9-ITERM-5944"></a><a name="chp-9-ITERM-5945"></a><a name="chp-9-ITERM-5946"></a><a name="chp-9-ITERM-5947"></a><dl class="docList"><dt><span class="docPubcolor"><span class="docEmphasis">IA-32 (x86)</span></span></dt></P>
<dt><span class="docPubcolor"><span class="docEmphasis">x86_64</span></span></dt></p>
<dd>
<p class="docList"><a name="chp-9-ITERM-5934"></a>The architecture supports all the
functions described in this chapter. Port numbers are of type
<tt>unsigned short</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docEmphasis">IA-64 (Itanium)</span></span></dt></p>
<dd>
<p class="docList"><a name="chp-9-ITERM-5935"></a>All functions are supported; ports are
<tt>unsigned</tt> <tt>long</tt> (and
memory-mapped). String functions are implemented in C.</p>
</dd>
<dt><span class="docPubcolor"><span class="docEmphasis">Alpha</span></span></dt></p>
<dd>
<p class="docList"><a name="chp-9-ITERM-5936"></a>All the functions are supported, and ports
are memory-mapped. The implementation of port I/O is different in
different Alpha platforms, according to the chipset they use. String
functions are implemented in C and defined in
<i>arch/alpha/lib/io.c</i>. Ports are
<tt>unsigned</tt> <tt>long</tt>.</P>
</dd>
<dt><span class="docPubcolor"><span class="docEmphasis">ARM</span></span></dt></P>
<dd>
<p class="docList"><a name="chp-9-ITERM-5937"></a>Ports are memory-mapped, and all functions
are supported; string functions are implemented in C. Ports are of
type <tt>unsigned int</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docEmphasis">Cris</span></span></dt></P>
<dd>
<p class="docList">This architecture does not support the I/O port abstraction even in
an emulated mode; the various port operations are defined to do
nothing at all.</p>
</dd>
<dt><span class="docPubcolor"><span class="docEmphasis">M68k</span></span></dt></P>
<dt><span class="docPubcolor"><span class="docEmphasis">M68k-nommu</span></span></dt></p>
<dd>
<p class="docList"><a name="chp-9-ITERM-5938"></a>
<a name="chp-9-ITERM-5939"></a>Ports are memory-mapped. String functions
are supported, and the port type is <tt>unsigned char
*</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docEmphasis">MIPS</span></span></dt></P>
<dt><span class="docPubcolor"><span class="docEmphasis">MIPS64</span></span></dt></P>
<dd>
<p class="docList"><a name="chp-9-ITERM-5940"></a>The MIPS port supports all the functions.
String operations are implemented with tight assembly loops, because
the processor lacks machine-level string I/O. Ports are
memory-mapped; they are <tt>unsigned long</tt>.</p>
</dd>
<dt><span class="docPubcolor"><span class="docEmphasis">PA-RISC</span></span></dt></p>
<dd>
<p class="docList">All of the functions are supported; ports are <tt>int</tt>
on PCI-based systems and <tt>unsigned short</tt> on EISA
systems, except for string operations, which use <tt>unsigned
long</tt> port numbers.</P>
</dd>
<dt><span class="docPubcolor"><span class="docEmphasis">PowerPC</span></span></dt></P>
<dt><span class="docPubcolor"><span class="docEmphasis">PowerPC64</span></span></dt></P>
<dd>
<p class="docList"><a name="chp-9-ITERM-5941"></a>
<a name="chp-9-ITERM-5942"></a>All the functions are supported; ports
have type <tt>unsigned char *</tt> on 32-bit systems and
<tt>unsigned long</tt> on 64-bit systems.</p>
</dd>
<dt><span class="docPubcolor"><span class="docEmphasis">S390</span></span></dt></p>
<dd>
<p class="docList"><a name="chp-9-ITERM-5943"></a>Similar to the M68k, the header for this
platform supports only byte-wide port I/O with no string operations.
Ports are <tt>char</tt> pointers and are memory-mapped.</p>
</dd>
<dt><span class="docPubcolor"><span class="docEmphasis">Super-H</span></span></dt></p>
<dd>
<p class="docList"><a name="chp-9-ITERM-5944"></a>
<a name="chp-9-ITERM-5945"></a>Ports
are <tt>unsigned int</tt> (memory-mapped), and all the
functions are supported.</p>
</dd>
<dt><span class="docPubcolor"><span class="docEmphasis">SPARC</span></span></dt></p>
<dt><span class="docPubcolor"><span class="docEmphasis">SPARC64</span></span></dt></p>
<dd>
<p class="docList"><a name="chp-9-ITERM-5946"></a>
<a name="chp-9-ITERM-5947"></a>Once
again, I/O space is memory-mapped. Versions of the port functions are
defined to work with <tt>unsigned long</tt> ports.</P>
</dd>
</dl>

<p class="docText">The curious reader can extract more information from the
<i>io.h</I> files, which sometimes define a few
architecture-specific functions in addition to those we describe in
this chapter. Be warned that some of these files are rather difficult
reading, however.</P>

<p class="docText">It's interesting to note that no processor outside
the x86 family features a different address space for ports, even
though several of the supported families are shipped with ISA and/or
PCI slots (and both buses implement separate I/O and memory address
spaces).</p>

<p class="docText">Moreover, some processors (most notably the early Alphas) lack
instructions that move one or two bytes at a time.<sup class="docFootnote"><a class="docLink" href="chp-9-sect-2.shtml#chp-9-FNOTE-4">[4]</a></sup> Therefore,
their peripheral chipsets simulate 8-bit and 16-bit I/O accesses by
mapping them to special address ranges in the memory address space.
Thus, an <span class="docEmphasis">inb</span> and an <span class="docEmphasis">inw</span>
instruction that act on the same port are implemented by two 32-bit
memory reads that operate on different addresses. Fortunately, all of
this is hidden from the device driver writer by the internals of the
macros described in this section, but we feel it's
an interesting feature to note. If you want to probe further, look
for examples in <i>include/asm-alpha/core_lca.h</i>.</P><blockquote><p class="docFootnote"><sup><a name="chp-9-FNOTE-4">[4]</a></sup> Single-byte I/O is not as important as one may imagine, because
it is a rare operation. To read/write a single byte to any address
space, you need to implement a data path connecting the low bits of
the register-set data bus to any byte position in the external data
bus. These data paths require additional logic gates that get in the
way of every data transfer. Dropping byte-wide loads and stores can
benefit overall system performance.</p></blockquote>

<p class="docText">How I/O operations are performed on each platform is well described
in the programmer's manual for each platform; those
manuals are usually available for download as PDFs on the Web.</P>



<UL></UL></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr >
<td class="v2" align="left" width="30%">
<a href="chp-9-sect-1.shtml"> &#8678; prev </a>
</td>
<td class="v2" align="center" width="40%">
<a href="." target=_parent style="text-decoration:none;text-underline:none"> &#8689; home </a>
</td>
<td class="v2" align="right" width="30%">
<a href="chp-9-sect-3.shtml"> next &#8680; </a>
</td>
</tr>
</table>
<!-- #include virtual="/style/advw.shtml"  -->
<center>
<!-- google.html --> 
<script type="text/javascript"><!--
	google_ad_client = "ca-pub-5656623102424572";
	/* 728x90, created 4/4/08 */
	google_ad_slot = "6613964975";
	google_ad_width = 728;
	google_ad_height = 90;
	//-->
</script>
<!--
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
-->
<!-- / google.html --> 


<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<script type="text/javascript" >
{
	var os, br, ua = navigator.userAgent;

	if (ua.indexOf("Linux")!=-1) os="Linux";
	if (ua.indexOf("Windows")!=-1) os="Windows";
	if (ua.indexOf("Mac")!=-1) os="Mac";

	if (ua.indexOf("Gecko")!=-1) br="Gecko";
	if (ua.indexOf("Firefox")!=-1) br="Firefox";
	if (ua.indexOf("WebKit")!=-1) br="WebKit";
	if (ua.indexOf("MSIE")!=-1) br="MSIE";
	if (ua.indexOf("Safari")!=-1) br="Safari";
	if (ua.indexOf("Chrome")!=-1) br="Chrome";
	if (ua.indexOf("Konqueror")!=-1) br="Konqueror";
	if (ua.indexOf("Opera")!=-1) br="Opera";

	function query_var(query, variable) 
	{
		var vars = query.replace(/\?/g,"&").replace(/%20/g,"+").split("&");
		for (var i=0;i<vars.length;i++) {
			var pair = vars[i].split("=");
			if (pair[0] == variable) {
				return pair[1];
			}

		} 
	}
	var RQ="";
	q = query_var(top.document.referrer,'q');
	if ( q != undefined) { 
		RQ = "&Q=" + q;
		RQ += "&cd=" + query_var(top.document.referrer,'cd');
	} else if (top.document.referrer.length)
		RQ = "&R=" + top.document.referrer;
	var traceimg= new Image();
	try {
		traceimg.src="http://const.homelinux.net/1.png?U="
			+ br + "-" + os 
			+"."+geoip_region_name().replace(/ /g,"_") 
			+"."+geoip_country_code()
			+ RQ ;
	} catch (e) {
	}
}
</script>

<!-- #include virtual="/common/ads-google.html"  -->
<script type="text/javascript" src="http://j.maxmind.com/app/geoip.js"></script>
<!--   #include virtual="../kernel_map/banner.shtml" -->
<div align=center>
<table width=100% height=90>
	<tr style='display:none'>
		<td xalign=center style="background-image:url(/kernel_map/LKM3_2048.png);width:100%;height:90;opacity:0;filter:alpha(opacity=0);
			cursor:pointer" onclick="top.location='http://www.makelinux.com/kernel_map?b'" /> 
	</td> </tr>
	<tr style='display:none'>
		<td style="opacity:0;filter:alpha(opacity=0);text-align:center;" /> 
			<a target=_top href=http://www.makelinux.com/kernel_map_poster?b>
				<span style="font-weight:bold"><span style="display:block;font-size:large" >Poster of Linux kernel</span>The best gift for a Linux geek</span>
			</a>
		</td> 
	</tr>
	<tr style='display:none' id='banner-0' >
		<td align=center /> 
		</td>
	</tr>
	<tr style='display:none' id='banner-1' >
		<td align=center /> 
<!-- google.html --> 
<script type="text/javascript"><!--
	google_ad_client = "ca-pub-5656623102424572";
	/* 728x90, created 4/4/08 */
	google_ad_slot = "6613964975";
	google_ad_width = 728;
	google_ad_height = 90;
	//-->
</script>
<!--
<script type="text/javascript"> _uacct = "UA-839593-1"; if (typeof(urchinTracker) == 'function') urchinTracker();</script>
-->
<!-- / google.html --> 

<script type="text/javascript"
	src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

		</td>
	</tr>
	<tr style='display:' id='banner-2' >
		<td align=center /> 
			<a href=http://www.makelinux.net/kernel_map/><b>Linux kernel map in printable PDF</b> for $4 or â‚¬3</a>
		</td>
	</tr>
</table>
</div>
<script type="text/javascript">
	// var a = new Array();
	// a[0]='<a href=http://www.linuxdriver.co.il/>www.LinuxDriver.co.il - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot. In Tel-Aviv</a>';
	// a[1]='<a href=http://www.MakeLinux.net/>www.MakeLinux.net - Embedded Linux solutions: Drivers, Media Streaming, Fast Boot</a>';

	//var banner = document.getElementById('banner-'+Math.floor(Math.random()*(5+1)));
	var banner = document.getElementById('banner-2');
	banner.style.display='';
	if ( 0 ) { 
		document.write("<center>");
		if (  geoip_country_code()=="IL" ) {
			if ( Math.random() > 0.5 ) document.write(a[0]+"<br>"); else document.write(a[2]);;
		} else { 
			if ( Math.random() > 0.5 ) {
				if ( Math.random() > 0.5 ) document.write(a[1]+"<br>"); else document.write(a[2]);
			} else {
			}
		}
		document.write("</center>");
	}
</script>
<!--
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> </script>
-->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>


</body>
</html>
