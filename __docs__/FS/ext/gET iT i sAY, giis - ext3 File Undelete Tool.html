<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>gET iT i sAY, giis - ext3 File Undelete Tool</title>
<script language="javascript">
// JavaScript Document
var menu1=new Array()
	menu1[0]='<a href="../giis_user_guide.html" title="User Guide">User Guide</a>'
	menu1[1]='<a href="../giis_mysql_screenshots.html" title="DB Recovery">DB Recovery</a>'
	menu1[2]='<a href="../manuals.html" title="Manuals">Manuals</a>'
		
var menu2=new Array()
	menu2[0]='<a href="../books.html" title="Books">Books</a>'
	menu2[1]='<a href="../programs.html" title="C Programming">C Programming</a>'
	menu2[2]='<a href="../python.html" title="Python Programming">Python Programming</a>'
	
var menuwidth='100px'
var menubgcolor='#000000'
var disappeardelay=250 
var hidemenu_onclick="yes"



var ie4=document.all
var ns6=document.getElementById&&!document.all

if (ie4||ns6)
document.write('<div id="dropmenudiv" style="visibility:hidden;width:'+menuwidth+';background-color:'+menubgcolor+'" onMouseover="clearhidemenu()" onMouseout="dynamichide(event)"></div>')

function getposOffset(what, offsettype){
var totaloffset=(offsettype=="left")? what.offsetLeft : what.offsetTop;
var parentEl=what.offsetParent;
while (parentEl!=null){
totaloffset=(offsettype=="left")? totaloffset+parentEl.offsetLeft : totaloffset+parentEl.offsetTop;
parentEl=parentEl.offsetParent;
}
return totaloffset;
}


function showhide(obj, e, visible, hidden, menuwidth){
if (ie4||ns6)
dropmenuobj.style.left=dropmenuobj.style.top="-500px"
if (menuwidth!=""){
dropmenuobj.widthobj=dropmenuobj.style
dropmenuobj.widthobj.width=menuwidth
}
if (e.type=="click" && obj.visibility==hidden || e.type=="mouseover")
obj.visibility=visible
else if (e.type=="click")
obj.visibility=hidden
}

function iecompattest(){
return (document.compatMode && document.compatMode!="BackCompat")? document.documentElement : document.body
}

function clearbrowseredge(obj, whichedge){
var edgeoffset=0
if (whichedge=="rightedge"){
var windowedge=ie4 && !window.opera? iecompattest().scrollLeft+iecompattest().clientWidth-15 : window.pageXOffset+window.innerWidth-15
dropmenuobj.contentmeasure=dropmenuobj.offsetWidth
if (windowedge-dropmenuobj.x < dropmenuobj.contentmeasure)
edgeoffset=dropmenuobj.contentmeasure-obj.offsetWidth
}
else{
var topedge=ie4 && !window.opera? iecompattest().scrollTop : window.pageYOffset
var windowedge=ie4 && !window.opera? iecompattest().scrollTop+iecompattest().clientHeight-15 : window.pageYOffset+window.innerHeight-18
dropmenuobj.contentmeasure=dropmenuobj.offsetHeight
if (windowedge-dropmenuobj.y < dropmenuobj.contentmeasure){ //move up?
edgeoffset=dropmenuobj.contentmeasure+obj.offsetHeight
if ((dropmenuobj.y-topedge)<dropmenuobj.contentmeasure) //up no good either?
edgeoffset=dropmenuobj.y+obj.offsetHeight-topedge
}
}
return edgeoffset
}

function populatemenu(what){
if (ie4||ns6)
dropmenuobj.innerHTML=what.join("")
}


function dropdownmenu(obj, e, menucontents, menuwidth){
if (window.event) event.cancelBubble=true
else if (e.stopPropagation) e.stopPropagation()
clearhidemenu()
dropmenuobj=document.getElementById? document.getElementById("dropmenudiv") : dropmenudiv
populatemenu(menucontents)

if (ie4||ns6){
showhide(dropmenuobj.style, e, "visible", "hidden", menuwidth)


dropmenuobj.x=getposOffset(obj, "left")
dropmenuobj.y=getposOffset(obj, "top")
dropmenuobj.style.left=dropmenuobj.x-clearbrowseredge(obj, "rightedge")+"px"
dropmenuobj.style.top=dropmenuobj.y-clearbrowseredge(obj, "bottomedge")+obj.offsetHeight+"px"
}

return clickreturnvalue()

}

function clickreturnvalue(){
if (ie4||ns6) return false
else return true
}

function contains_ns6(a, b) {
while (b.parentNode)
if ((b = b.parentNode) == a)
return true;
return false;
}

function dynamichide(e){
if (ie4&&!dropmenuobj.contains(e.toElement))
delayhidemenu()
else if (ns6&&e.currentTarget!= e.relatedTarget&& !contains_ns6(e.currentTarget, e.relatedTarget))
delayhidemenu()
}

function hidemenu(e){
if (typeof dropmenuobj!="undefined"){
if (ie4||ns6)
dropmenuobj.style.visibility="hidden"
}
}

function delayhidemenu(){
if (ie4||ns6)
delayhide=setTimeout("hidemenu()",disappeardelay)
}

function clearhidemenu(){
if (typeof delayhide!="undefined")
clearTimeout(delayhide)
}

if (hidemenu_onclick=="yes")
document.onclick=hidemenu
</script>
<link rel="stylesheet" href="../css/giis.css" type="text/css" />
</head>

<body>
<table width="900" border="0" cellspacing="0" cellpadding="0" align="center">
  <tr>
    <td height="10"></td>
  </tr>

  <tr>
  	<td align="center">
        <table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td width="117"><a href="../index.html" title="giiS"><img src="../images/logo.gif" border="0" /></a></td>
    <td class="goog1" width="533"><script src="http://www.gmodules.com/ig/ifr?url=http://www.google.com/ig/modules/translatemypage.xml&up_source_language=en&w=160&h=60&title=&border=&output=js"></script></td>
  </tr>
</table>
	</td>
  </tr>	  
  <tr>
    <td height="24"></td>
  </tr>
  <!-- Menu starting here -->
  <tr>
    <td align="center">
		<table width="650" height="24" border="0" cellspacing="0" cellpadding="0">
		  <tr align="center">
			<td width="73"><a href="../index.html" class="nav" title="Home">Home</a></td>
			<td width="1">|</td>
			<td width="103"><a href="../download.html" class="nav" title="Download">Download</a></td>
			<td width="1">|</td>
			<td width="135" onmouseover="dropdownmenu(this, event, menu1, '135px')" onmouseout="delayhidemenu()" title="Documentation"><span class="nav">Documentation</span></td>
			<td width="1">|</td>
			<td width="135" onmouseover="dropdownmenu(this, event, menu2, '135px')" onmouseout="delayhidemenu()" title="Programming"><span class="nav">Programming</span></td>
			<td width="1">|</td>
			<td width="62"><a href="../FAQ.html" class="nav" title="FAQ">FAQ</a></td>
			<td width="1">|</td>
			<td width="127"><a href="../readme.html" class="nav" title="About Me">About Me</a></td>
		  </tr>
		</table>
	</td>
  </tr>
  <!-- Menu ends here -->

   <tr>
    <td>
		<table width="700" border="0" cellspacing="0" cellpadding="0" align="center">
		  <tr>
		    <td height="10"></td>
		  </tr>
		  <tr>
			<td width="700" class="line" height="1"></td>
		  </tr>
		  <tr>
		    <td height="10"></td>
		  </tr>
		</table>
	</td>
   </tr>
  <!-- Middle part starts here -->
  
  <tr>
    <td align="center">
		
	</td>
  </tr>
<!-- Middle part ends here -->  
  <tr>
  	<td align="center" valign="top">
		<table width="650" cellspacing="0" cellpadding="0" align="center">
		  <tr>
		    <td height="15"></td>
  		  </tr>
		  <tr>
			<td class="midhead">
			
				<table width="650" border="0" cellspacing="0" cellpadding="0">
				  <tr>
					<td class="midhead" height="30" align="left" colspan="2">KICK STARTING WITH EXT3/EXT2 FILE SYSTEM</td>
				  </tr>
				  <tr>
					<td class="s_head" height="30" colspan="2" align="left">An Incomplete and Unreliable Guide to File system
							 </td>
				  </tr>
				  <tr>
					<td width="350"></td>
					<td class="midtxt1" align="left">
					By<br />
					G.Lakshmipathi.<br />
					July 2005.
					</td>
				  </tr>
				</table>
			
			</td>
		  </tr>
		  <tr>
			<td class="midtxt1"><br />
			<span class="s_head">INTRODUCTION:</span><br /><br />

Hi! I'm happy to share few information on file system with you.One thing i want to make it clear, i may be carried away a bit, at times, that's purely because i want to keep readers interested and nothing more than that.<br />

<span class="s_head">WARNING:</span><br />
<span class="s_head">*******</span><br />
	If you don't want to mess up with file system.Delete this file.Right Now.<br /><br />
<span class="s_head">CAUTION:</span><br />
<span class="s_head">*******</span><br />
	If you want to mess up a little bit with then Try other "useful materials".<br /><br />
<span class="s_head">DANGER:</span><br />
<span class="s_head">******</span><br />
	If you ready to lose all data and don't care even your system explodes like a bomb.<br />
	... Got a right man.. go on..<br /><br />

<span class="s_head">How to Xplore this</span><br /><br />

Go through this doc at the same time (underline the word same time ) try out some coding's on your own . Afterall the worst thing that can happen is ,"End up with losing all data ." I Believe you don't have confidential data.Certainly i don't have it.<br /><br />
<span class="s_head">Let's get started,</span><br /><br />

file system --mm...10 letters,so from here onwards,<br />
#define file_system FS<br />
FS consists of data in an organized way. In what way? there should plenty of ways to do it.That's why we have so many FS. Let's talk about Linux FS. When we say Linux FS,it may be anything.But most often ext2 or ext3 is used. From here on When i say FS i refers to EXT2 or EXT3 because i don't about other filesystem that doesn't mean i know everything in EXT FS.<br /><br />

<span class="s_head">O.k</span><br /><br />

Let's kick start and learn some basics right.  --as far as possible.<br />
Some key terms in EXT FS are,<br />
1)Blocks<br />
2)Inode<br /><br />
3)Super block
4)Group Descriptor<br />
5)Data block bitmap<br />
6)Inode Bitmap<br />
7)Inode Table<br /><br />


<span class="s_head">Blocks</span><br /><br />

Blocks consists of fixed number of bytes. Block size may be 1024,2048,4096. If you find it diffcult to understand, Think of it as an array say , char b[4096];<br /><br />

Size of block can be calculated using the formula,<br /><br />

Block_size=1024*2@s_log_block_size;<br />
Wondering what that's @ mean,<br />
It's not a operator.<br />
@--->denotes power-of<br />
so if you s_log_block_size=2<br />
then your<br />
	Block_size=1024*2@2=1024*4=4096<br />
 the s_log_block_size can be found at super block entry.<br /><br />


<span class="s_head">Inode & Inode numbers</span><br /><br />

Most often you hear term inode in FS.Each file has unique inode.inode is nothing but a number used by kernel to identify each file. Remember in GNULinux/Unix everything is file.Harddisk is file.Keyboard is a file. Everydevice is a file and each has its own unique number called inode number. Each and every file has a inode structure which consists of permission : who can access this file rwxr_xr_x, file type :what kind of file is this? a regular file or directory or socket or pipe or a device Time:Creation time,Deletion time etc. Pointer to Data blocks : To contents of the file it has 15 pointers to data blocks. We will discuss about these blocks managed and how to access the data a little bit later. But for now,i_blocks[0] will pointed to Beginning of file content. Take a look at ext3_fs.h for more.<br /><br />
First i thought about providing examples here n there but i didn't do that since much more fun and thrill in journey when we don't what will happen next.So try on your own to access superblock,and then group descriptor and others.Just enjoy!!!.<br /><br />

<span class="s_head">A Hint for beginners:</span><br />
First define a union similar to super block or anything other struct you want to access.<br />
say like,<br /><br />

union me{<br />
	struct ext3_super_block{<br />

				}info;<br />
	char buffer[sizeof(struct ext3_super_block)];<br />
	}giis;<br /><br />
	

Open the file "/dev/hda7 " in read only mode.So that FS is not damaged...<br />
use lseek() or lseek64() to move to offset.<br />
read() into our buffer and then access.<br />
Now,Try n access an inode say root. )<br /><br />

<span class="s_head">Super block</span><br />
i forgot something,<br />
#define super_block SB<br />
#define Group_descriptor GD<br /><br />

Keypoint is SB is at offset 1024 and it's size is 1024. SB contains information on total number of inode,free blocks. <br />first_inode,first_data_blocks and magic number which will be "ef53" -i believe it's id of both EXT2 and EXT3 (I'm pretty sure) take look at your SB structure at ext3_fs.h file. Go and search for ext3_fs.h file in your system now if doesn't know those entry while I'm searching for that file. O.k you can find inode,group_descriptor structure on that file too. Wondering what that _u32 or _u16 means? u refers to unsigned where as _s32,_s16 s refers to its counterpart signed one. 32,16 refers to number of bits.<br /><br />

Coming to superblocks,in 5GB there will approximately 40 Block-Groups. Then there has to be as many as 40 superblocks,for a 5GB of partition size. Each block group has SB,GD,Data block bitmap,inode bitmap,inode table.So we have 40 of them each.<br /><br />

5GB->5*1024=5120MB<br />
Since Block size is 4KB or 4096 bytes can represent 32K data blocks or 128MB<br />
No.of Block Groups ==5120/128=40 Block groups.<br /><br />

Smaller the block_size results in large number of block-groups.<br /><br />

Presently I'm doing some messup with FS like accessing and modifying super_block,group descriptors ,data block bitmap,inode bitmap,inode table. Accessing these entries from Block-Group-0 seems to be much easy. But to access them from next Block-group-1 is proves to be very diffcult.So far,I tried many thing to get them but all resulted in -- mm...i don't call it as failure because they provide some other information which may be or just might be more vital than i'm what searching for.<br /><br />

Thus if each of these of these Block-groups has one super-block and one Group Descriptor so we have 40 Superblocks and 40 Group descriptor. These 40 Superblocks are same.Only the first superblock is used by kernel. The remaining 39 superblocks are substitute (39 Substitute... much more than no.of players in cricket) The 39 Group Descriptor are also substitutes. How to traverse through these block-group?(which we see later --Hopefully) In SB there is entry s_block_group_nr which says what block-group we are currently in. Believe me,if know some basics you can do things that you may not imagined within a week yes within 7 days you will be in total new world. So go on...<br /><br />

<span class="s_head">Group Descriptor:</span><br /><br />

So we got some basics of block and super blocks now we turn our knife towards group
descriptors.<br />
GD is very critical for FS.It consists of the following,<br />
	Starting Block number of data bitmap of current GD.<br />
	Starting Block number of inode bitmap of current GD.<br />
	Starting Block number of inode table of current GD.<br />
And<br />
	no.of free data blocks and inodes of this GD.<br /><br />

Just a week or so before when i come across bitmap i said "What the hell this is bitmap?" Since i think GD is THE most important part in FS most of remaining doc will be on GD. First three entries are very important. I think,these three entries of GD along with s_block_group_nr of SB used in access data from other block-groups. Since we know GD is next to SB,starting address of GD=block_size (say 4096)<br /><br />
i got it !Just now I got that most vital information!. It's not as much diffcult to access other blocks as i first thought it's very simple. You are not able to access other block-Group directories simply because there are far far away. unsigned long range is 0 to 4294967295,so in order to access say for example 4294967298th byte, it's 3 bytes more than the actual range.<br /><br />

	So i tired this ,
			lseek(fd,4294967295,0);
			lseek(fd,3,1);/* from current */

But Yes we can reach that byte but still there is major problems.You cannot access it because of range limitations while computing.That's when i remember Gadi Oxman said something about lseek() in his Doc part.Thanks Gadi Oxmen!!!
To access larger files use llseek(). lseek() must also be replaced with llseek() or lseek64().Use lseek64. so you can't use data type of "unsigned long" instead use "unsigned long long" obviously, so finally a week long expedition coming to nice end by accessing /home dir.<br /><br />

The following shows GD struct (see it in ext3_fs.h )<br /><br />

/*<br />
 * Structure of a blocks group descriptor<br />
 */<br />
struct ext3_group_desc<br />
{<br />
	__u32	bg_block_bitmap&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Blocks bitmap block */<br />
	__u32	bg_inode_bitmap&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Inodes bitmap block */<br />
	__u32	bg_inode_table;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Inodes table block */<br />
	__u16	bg_free_blocks_count;&nbsp;&nbsp;&nbsp;&nbsp;/* Free blocks count */<br />
	__u16	bg_free_inodes_count;&nbsp;&nbsp;&nbsp;&nbsp;/* Free inodes count */<br />
	__u16	bg_used_dirs_count;&nbsp;&nbsp;&nbsp;&nbsp;/* Directories count */<br />
	__u16	bg_pad;<br />
	__u32	bg_reserved[3];<br />
};<br /><br />

I cut-n-pasted GD struct, group descriptor may be seems to be diffcult but it's very simple.Understanding group descriptor allows to access any file or directory by using it's inode number only. Since you know that root inode number is 2. That's Great!. Now you can access files that starts with /. (Entire System) Note that root is parent of all files.So Now you can access all files by knowing that root inode is 2.Rest of it very simple. Remember all block group has SB,GD,data block bitmap,inode bitmap,inode table.<br /><br />

Following are most important values,<br />
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bg_block_bitmap.<br />
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bg_inode_bitmap.<br />
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bg_inode_table<br /><br />

Let's spend sometime with bg_inode_table since knowing this makes the remaining two easier. inode_table is nothing but inode itself. Say, bg_inode_table=4 Then it refers to block number 4 where all inodes related to this are stored in the format ext3_inode of size 128 bytes. w.k.t,(-We know That)<br />

Block_size=4096<br />
inode_size=128<br />
The no.of inode_per_block=4096/128=32<br />
W.k.t,<br />
inodes_per_group=16320<br />
So there is 510 blocks of inode table is available<br /><br />

If don't understand the above said 510 blocks of inode table .NO PROBLEM. It's Just an information which is not needed and used here after.Because that might lead to serious confusion.( Not for you ...but for me :-})<br /><br />

So getting back where we feel confident<br />
if<br />
 bg_inode_table=4<br />
4 is block number.If we know blocknumber then to access that block's content,<br /><br />
 
<span class="s_head">LittleFinger Rule is:</span><br /><br />
Address=block_number*block_size;<br />
address=4*4096=16384<br />
so we got offset of inode_table.<br />
if struct ext3_inode size=128 then<br />
inode number 1 is at 16384<br />
inode number 2 is at 16384+128=16512<br />
Yes got root inodes offset 16512.<br />
So we can access it's contents.<br /><br />

That's it .so easy...Keep going..<br />
Steps to access root inode or any inode:<br /><br />

1)First get the inodes group number.<br />
2)From group number we have to access inode_table entry of that group Descriptor by computing<br />
group offset.<br />
3)Then compute inode offset.<br /><br />

For example,(once again )to find root's offset,<br />
1)Group Descriptor number or group number = (inode_number-1) / inodes_per_group<br />
then Group number=0.<br /><br />

2)Then Get offset of group number 0,<br />
Group offset=Block_size+group_number*sizeof(struct group_desc)<br />
Group offset=4096+0*32=4096.<br />
Set lseek(fd,4096,0)<br />
read(fd,buffer,Sizeof(struct group_desc)<br />
Display inode_table value which is 4 (in my system )<br /><br />

3)Then root_inode_offset=inode_table*block_size+index_number*sizeof(ext3_inode)<br />
Where<br />
index_number=(inode_number-1)%inodes_per_group<br />
root_inode_offset=4*4096+1*128=16512<br /><br />

Finally we got the offset then, use lseek() to go there read() to get root inode entries. Here we got only root_inode_structure (ext3_inode of root) Then where is it's contents like subdirectories /bin,/home etc.<br /><br />

Always note that inode is somekind of book-keeping about each files so it contains only some attributes or characteristic of a file.The content of file is at another block indicated by i_block[0]. i_block[] has direct entry,indirect entry,double indirect entry and triple indirect entry. We see them soon until let's deal with i_block[0] i_block[] is integer values it denotes block number i_block[0] is 514 Then the content of the root inode is kept at block number 514.<br /><br />

So in order to access that block, Use our littlefinger rule Address=514*4096; So use lseek() to move to that address. Then read() and See what comes out... Some known and unknown data.. just wait a bit ... Once you move to that address one cannot just read like that, You have to now how it's contents are stored. Contents are stored as in format of struct ext3_dir_entry_2{} So while retrieve use this struct format to read the content.<br /><br />

<span class="s_head">o.k</span><br /><br />

we can access root_inode and it's contents. What's left ? We are nearing the end of file system basics.(since i think i don't much about file system so can't write/type more...) Regarding inode or blocks bitmaps is a map which gives you idea about which inode is used and which is free. For example , Move to block bitmap which will be at 4096 from the end of super block. i.e next to group descriptor.<br /><br />

char a;<br />
FD--> file system say /dev/hda6<br />
read(fd,&a,1);<br /><br />

So we read a char from block bitmap, This one byte will consists of details about 8 blocks.Yes each bit denotes whether block is free or used.Free is denoted by 0 and used by 1. Then read next byte, It will have information about block 8 to 16 and so on..<br /><br />

Inode bitmap is same as block bitmap. Go to inode block which is at the end of block bitmap read a byte which gives you 8 inodes details Remember one more thing,each block bitmap block contains information about 32768 blocks (blocks_per_group) In order to access 32770 you have get block bitmap of next group Descriptor. Same the case with inodes too. Remember THE most important thing is whenever you want to access inode or block ,First Get it's group number for further processing.<br /><br />

ext3 Journaled version of ext2. Journal refer to recording each activity from time to time so that when something goes wrong it can restored to its previous values. It records superblock,Group Descriptor,and inodes and data blocks too. I'm not sure and don't know much about Journal.<br /><br />
So.......<br />
The End.<br /><br />
O! just forgot about i_block[] , as i said before,(Yes i said... probably you may not heard it :-) first 12 are direct blocks. i_block[0] to i_block[11] will contain data block number.So access that block to read data.<br /><br />
<span class="s_head">How to access Single indirect Data blocks:</span><br /><br />
i_block[12]-Contains block number go to that block which does not have data instead of another block number which will hold the data - Single indirect block. i have tired to delay i_block[] since I'm not familiar with it.<br /><br />

What is pointer to data mean? How it really points to a block contains data? Here is some answer, For example, i_block[12]=12345; Then by definition 12345 must have a block number which contains data. Actually,we have more than one block number. Yes there are 1024 block numbers are available to support files up to 4.04M.B and these 1024 block numbers are data blocks.<br /><br />

Let's go a bit back and concentrate on direct blocks once again,<br />
there 12 direct blocks if each block size=4096 then file access with direct block<br />
is of size 48KB.<br />
i.e 12*4096/1024=48KB<br />
If we have 1024 block numbers in single indirect then file size must be<br />
1024*4096/1024/1024=4M.B<br />
add that direct block size 48KB to 4MB So one can access file file of 4.04MB of<br />
file size  using 12 direct and single indirect block.<br /><br />

Most of single indirect blocks are in sequential order.<br />
if i_block[12]=12344;<br />
lseek64(fd,i_block[12]*block_size,0)<br />
read(fd, indirect_block,4096);<br />
where indirect_block is an array of 1024 of type unsigned long.<br />
then indirect_block[0]=12345 ==> Access this block for data<br />
indirect_block[1]=12346<br />
and so on...<br />
indirect_block[1023]=13368<br /><br />

Mostly these blocks are in sequence. But sometimes during allocation if block is used then another block is used. So it's not a precondition that single indirect blocks are always sequential.I conducted a little test on files that use only direct block and single indirect block sequence. That is files that use i_block[0] to i_block[12].<br /><br /> 

<span class="s_head">Here is the result,</span><br />
Test1:<br />
Total files examined 132.<br />
Total files in which single indirect blocks are in sequence is 66.<br />
Total files in which single indirect blocks are not in sequence is also 66.<br /><br />

Out of these 66 files there only 22 files has  more than 50 holes.<br />
And 42 files has less than or equal to 5 holes.<br />
When i say holes it refers to no.of non-sequence entries in single indirect blocks of 1024.<br />
Number of non-consecutive blocks are  holes.<br />
For example,<br />
[0]=222111<br />
[1]=222112<br />
[2]=222114 ====>here we have a jump from 222112 to 222114 so hole 1.<br />
[3]=222115<br />
[4]=222116<br />
[5]=222125====>Hole 2<br />
...<br />
...<br />
...<br />
[1023]<br />
Test2:<br />
Total files 1071<br />
Not in sequence 600<br />
In sequence 471.<br />
297 files has Holes less than 5<br />
where as 237 files has holes greater than or =50<br /><br />

How to access Double indirect data blocks:<br />
About i_block[13] is also similar,<br /><br />

It's double indirect so access two blocks,<br />
i_block[13]=180217<br />
now lseek64(fd,i_block[13]*block_size,1)<br />
and read(fd,indirect_block,4096)<br />
say here we get indirect_block[0]=180218<br />
once again<br />
lseek64(fd,indirect_block[0]*4096,1);<br />
read(fd,indirect_block,4096)<br />
So indirect_block[0]=180219<br />
indirect_block[1]=180220<br />
...<br />
...<br />
...<br />
indirect_block[1023]=19234<br /><br />

How to Access files greater than 8.04MB:<br /><br />

when file size goes beyond 8.04MB obviously it needs more 1024 blocks.<br />
To make it clear let's have file named "blackhole" with size 11.5MB<br />
Up to i_block[12]  we accessed 4.04MB size.<br /><br />

i_block[13]=100;<br />
It's double indirect so lseek() and read() twice.<br />
We get 102 where data of "blackhole" begins,<br />
(note : if file fragmented we get any block say 103 or 155...)<br /><br />

Since each block run has maximum of 1024 blocks.<br />
[0]=102<br />
[1]=103<br />
[2]=104<br />
......<br />
......<br />
[1021]=1124<br />
[1022]=1125<br />
[1023]=1126<br /><br />

So now we access next 4MB (i.e from 4.04 to 8.04 MB) of the "blackhole" and so far<br /><br />
we access 8.04 MB.
Note that most vital thing in double indirect is that when a file is more than 8.04 MB.<br />
Now to access next block run another 1024 blocks we have pointer stored at<br />
[1023] block.That is the block 1126 is not the data but a pointer.<br />
So Think 1023 as i_block[13]<br /><br />

ie. i_block[13]=1126 (It's not real value just imagine like this only when you<br />
want to access more than 8.04MB.)<br />
Then again lseek() & read() twice we get data,<br />
[0]=1128<br />
[1]=1129<br />
....<br />
....<br />
[--]=0; ==> we reached 11.5MB size.<br />
....<br />
Since file size falls into this block run of 1024 we don't anymore imagination of i_block[13]<br />
is needed.<br />
If the file "blackhole" is 15MB instead of 11.5MB then,<br />
[0]=1128<br />
[1]=1129<br />
....<br />
....<br />
....<br />
[1022]=2151<br />
[1023]=2152<br /><br />

So far we access 12.04MB of "blackhole" in order to access up to 15MB,<br />
[1023] is a pointer.<br />
imagine [1023] as i_block[13]<br />
so i_block[13]=2152.<br />
Then again lseek() & read() twice we get data block,<br />
[0]=2154<br />
[1]=2155<br />
[2]=2156<br />
....<br />
....<br />
....<br />
[--]=0 ==> we reached file size 15MB<br /><br />

THE most important thing in double indirect block is whenever you want to access files<br />
more than 8.04MB IMAGINE i_block[13]=[1023] & lseek() and read() twice.<br />
in order to access next set 1024 data blocks.<br />
One important Note:<br /><br />

One more THE vital thing,when we have to access large files it's data block will be<br />
scattered and uses more than one group descriptors so keep checking whether the block belongs to<br />
this  group or not.If not then  find the blocks corresponding group number and then<br />
access.<br /><br />



An easy way remember simply use one lseek() and one read() for single indirect blocks. Use two lseek() and two read() for double indirect block. you will have series of block numbers. I guess in total there are 1049611 blocks will be used. So that we can access file as large as 4.GB<br />
On i_block[14] i can't say anything more than this,it will be used by EXT as a last weapon has against you.
I guess here we need three lseek() and three read() for triple indirect block.<br /><br />

<span class="s_head">Exercise:</span><br />
Try to creat a file which uses i_block[14] completely. It will be handy if you have harddisk of size 2T.B (:-}
Please complete the above exercise and sent to me in a floppy.<br /><br />

Finally,<br /><br />

I'm ending this doc simply because i don't know anything more than this about file system to type or write.I believe now you can access any inode and its content by using its number.
and Finally,<br /><br />

I hope this documentation of file system will helped at-least a bit in your work.<br />

I believe the  gET iT i sAY.giis. will also provide some more information on coding.<br />
See also  <a href="#" class="hlight">giis overview and implementation</a><br />

Send your comments or criticism or cash to lakshmipathi.g AT gmail.com<br />


#define cash "thanks"<br /><br />

The End.<br /><br />



<br /><br />

</td>
		  </tr>
		  <tr>
			<td height="12"></td>
		 
		</table>

	</td>
  </tr>	
  <tr>
  	<td>
		<table width="850" border="0" cellspacing="0" cellpadding="0" align="center">
		  <tr>
			<td height="1" class="line"></td>
		  </tr>
		</table>
	</td>
  </tr>	
     <tr>
  	<td height="60" class="foot_txt" align="center">
		Powered by<br> Open Source Programmers
	</td>
  </tr>	
</table>
</body>
</html>
