<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE>Operating Systems Development Series</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.1  (Win32)">
	<META NAME="CREATED" CONTENT="20111219;11292300">
	<META NAME="CHANGED" CONTENT="20111219;12572900">
	<STYLE TYPE="text/css">
	<!--
		@page { margin: 0.79in }
		P { color: #000000; font-family: "Verdana"; font-size: 9pt }
		TD P { margin-bottom: 0in; color: #000000; font-family: "Verdana"; font-size: 9pt }
		H1 { margin-top: 0in; margin-bottom: 0in; color: #00983e; font-family: "Verdana"; font-size: 16pt }
		H2 { margin-top: 0in; margin-bottom: 0in; color: #3e0098; font-family: "Verdana"; font-size: 13pt }
		H3 { margin-top: 0in; margin-bottom: 0in; color: #800040; font-family: "Verdana"; font-size: 11pt }
		PRE { color: #000000 }
		A:link { color: #666699 }
		A:visited { color: #666699 }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" TEXT="#000000" LINK="#666699" VLINK="#666699" DIR="LTR">
<table><tr><td>
<P><a href="http://www.brokenthorn.com"><IMG SRC="site/5.png" NAME="graphics1" ALIGN=BOTTOM WIDTH=375 HEIGHT=71 BORDER=0></a></p>
</td><td>
        <div id="ad_main">
		<script type="text/javascript"><!--
		google_ad_client = "pub-9243579471203558";
		google_ad_width = 468;
		google_ad_height = 60;
		google_ad_format = "468x60_as";
		google_ad_type = "image";
		google_ad_channel = "";
		google_ui_features = "rc:6";
		//-->
		</script> 
		<script type="text/javascript"
			src="http://pagead2.googlesyndication.com/pagead/show_ads.js"> 
		</script> 
        </div> 
</td></tr></table>

<TABLE WIDTH=100% BORDER=0 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% HEIGHT=12 BGCOLOR="#000080">
			<P STYLE="page-break-after: avoid"><FONT COLOR="#ffffff"><FONT FACE="Verdana, sans-serif"><FONT SIZE=2><B>Operating
			System Development Series</B></FONT></FONT></FONT></P>
		</TD>
	</TR>
</TABLE>
<P ALIGN=CENTER STYLE="margin-bottom: 0in"><FONT SIZE=2 STYLE="font-size: 9pt"><FONT COLOR="#003e98"><FONT SIZE=5 STYLE="font-size: 19pt"><B>IA32
Machine Language</B></FONT></FONT> <BR><FONT COLOR="#000000"><B>by
Mike, 2011</B></FONT></FONT></P>
<TABLE WIDTH=894 BORDER=0 CELLPADDING=5 CELLSPACING=0>
	<COL WIDTH=884>
	<TR>
		<TD WIDTH=884>
			<P><BR>
			</P>
			<H1 STYLE="margin-bottom: 0.2in">Introduction</H1>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">This chapter covers IA32
			machine language programming. The information provided here is for
			information purposes only and is not needed for the development of
			a basic operating system or executive software. Understanding the
			instruction format for the IA32 (and IA64) instructions can help
			debugging improperly assembled instructions, v86 monitors that are
			required for supporting v8086 mode, emulating instructions (which
			is required for emulating certain FPU instructions or when
			developing assemblers, emulators, virtual machines, and some other
			types of software), and when developing certain system software
			like debuggers and compilers.</FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">This chapter is also for
			testing a new editor being used to write the new chapters that
			should help improve formatting and resolve spelling errors. If
			this test is successful, all of the new and earlier chapters will
			be updated to reflect the new format. Please send any feedback if
			you encounter any errors.</FONT></P>
			<P><BR>
			</P>
			<H2 STYLE="margin-bottom: 0.2in">Machine Language Overview</H2>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><B>Machine language</B>,
			also known as <B>machine code, native code, </B><SPAN STYLE="font-weight: normal">and
			</SPAN><B>byte code,</B> is the set of raw instructions and data
			that can be executed by a <B>central processing unit (CPU)</B>. It
			allows a CPU to interpret a certain set of byte sequences as an
			&quot;instruction&quot; to perform a task. These tasks are very
			small, such as copying small amounts of data or arithmetic. The
			act of building a byte sequence that represents a CPU instruction
			is known as <B>coding</B>. The definition of <B>coding</B> has
			evolved as programming languages evolved. Originally the term
			referred to the actual coding of the byte sequence for an
			instruction; today it applies to many forms of programming in
			second, third, and fourth generation programming languages.
			Computer <B>programs</B><SPAN STYLE="font-weight: normal">, also
			known as </SPAN><B>software, </B><SPAN STYLE="font-weight: normal">is
			the collection of machine code and data that performs a
			complicated task, such as word processing or playing Halo&reg;.
			Machine language is often interpreted by popular media as a
			&ldquo;series of 1's and 0's&rdquo;. This is an accurate
			description&mdash;to an extent.</SPAN></FONT></P>
			<P><BR>
			</P>
			<H3 STYLE="margin-bottom: 0.2in"><B>Digital Logic</B></H3>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><B>Digital logic</B> <SPAN STYLE="font-weight: normal">is
			a field of electronics that utilizes </SPAN><B>logic gates</B>
			<SPAN STYLE="font-weight: normal">that allows the electronics to
			make decisions. Some examples of logic gates include </SPAN><B>AND
			gates, OR gates, NOR gates, NAND gates, NOT gates</B> <SPAN STYLE="font-weight: normal">and
			</SPAN><B>XOR gates.</B> <SPAN STYLE="font-weight: normal">These
			gates reflect their binary operations: AND gates perform a binary
			AND, XOR performs a binary XOR, and so on. In order for these
			gates to be meaningful, a standard needed to be adopted in order
			to make sense of what is </SPAN><B>true</B> <SPAN STYLE="font-weight: normal">and
			</SPAN><B>false</B><SPAN STYLE="font-weight: normal">. For
			example, AND gates only make sense if there are two inputs and one
			output. The two inputs are the two items to test for equality: if
			either one is false, the output is false else the output is true.
			The standard is to define a line with low electrical current as
			</SPAN><B>false</B> <SPAN STYLE="font-weight: normal">and a line
			with higher electrical current as </SPAN><B>true</B><SPAN STYLE="font-weight: normal">.
			This is what connects the binary number system to digital logic
			electronics. In the binary number system, </SPAN><B>0</B> <SPAN STYLE="font-weight: normal">is
			often denoted as </SPAN><B>false</B> <SPAN STYLE="font-weight: normal">and
			</SPAN><B>1</B> <SPAN STYLE="font-weight: normal">is often </SPAN><B>true</B><SPAN STYLE="font-weight: normal">.
			Machine language is often represented in binary because of its
			tight connection with the CPU instruction decoding mechanism and
			how its stored in RAM for instruction fetching.</SPAN></FONT></P>
			<P><BR>
			</P>
			<H3 STYLE="margin-bottom: 0.2in"><B>Program loading</B></H3>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">Programs are loaded into
			memory by the operating system, executive, or firmware. The IA32
			and IA64 family of CPU's can execute programs from <B>Read Only
			Memory (ROM)</B> <SPAN STYLE="font-weight: normal">and </SPAN><B>Random
			Access Memory (RAM)</B><SPAN STYLE="font-weight: normal">. This is
			made possible through a common </SPAN><B>system bus</B> <SPAN STYLE="font-weight: normal">and
			</SPAN><B>physical address space (PAS)</B> <SPAN STYLE="font-weight: normal">shared
			by firmware and program images. Because firmware and program
			images can both be executed directly by the CPU cores, they
			utilize the same machine language byte code. Machine language is
			different then </SPAN><B>microcode</B> <SPAN STYLE="font-weight: normal">(see
			chapter 7) that firmware might use, however, the actual firmware
			is still machine language.</SPAN></FONT></P>
			<P><BR>
			</P>
			<H3 STYLE="margin-bottom: 0.2in">Assembly language</H3>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><B>Assembly language</B> is
			a <B>second generation programming language</B>. It allows the
			programmer to write a program in a well defined language that uses
			<B>mnemonics</B> to aid the programmers in developing the
			software. For example, <B>MOV</B> <SPAN STYLE="font-weight: normal">is
			a common mnemonic common in a lot of assembly languages for
			different architectures. </SPAN><B>MOV</B> <SPAN STYLE="font-weight: normal">represents
			an instruction that copies data from a source to a destination. It
			is also an example of a </SPAN><B>data movement instruction</B><SPAN STYLE="font-weight: normal">.</SPAN></FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">The mnemonics gave a
			symbolic name to the instructions and instruction forms, allowing
			each assembly language instruction to be translated to a single
			(in some cases, several possible) machine language byte sequences.
			The program that translates assembly language instructions into
			machine language is known as an <B>assembler</B>. Assemblers are
			sometimes incorrectly called <B>compilers</B><SPAN STYLE="font-weight: normal">.</SPAN></FONT></P>
			<P><BR>
			</P>
			<H2 STYLE="margin-bottom: 0.2in">Machine Instruction overview</H2>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">A
			</SPAN><B>machine instruction</B> <SPAN STYLE="font-weight: normal">is
			a single byte sequence that performs a specific task for the CPU.
			A set of machine instructions has been previously defined as a
			</SPAN><B>machine language</B><SPAN STYLE="font-weight: normal">.
			Machine instructions are defined by a CPU manufacturer in an
			</SPAN><B>instruction set</B> <SPAN STYLE="font-weight: normal">that
			documents all of the CPU instructions the manufacturer
			implemented. Instruction sets also typically include suggestive
			assembly language mnemonics for assembler developers to use.
			Instruction sets are documented in CPU specifications.</SPAN></FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">The
			CPU manufacture implements the machine instructions supported by a
			particular CPU and how the CPU interprets each instruction. This
			allows the CPU to &ldquo;execute&rdquo; machine instructions that
			the manufacture intended. Bugs in the CPU hardware or firmware,
			however, can cause the CPU to &ldquo;execute&rdquo; instructions
			that are not valid instructions. These are </SPAN><B>undocumented
			instructions</B><SPAN STYLE="font-weight: normal">. Some
			assemblers might define mnemonics to undocumented instructions
			that are well known. Some undocumented instructions that have had
			benefits have later become documented as real instructions. Some
			instructions might be left undocumented for manufacturer testing
			use only, such as the IA32</SPAN> <B>LOADALL</B> <SPAN STYLE="font-weight: normal">instruction
			(this bug has since been fixed.) Some instructions might also have
			bad effects, such as halting the system or damaging the CPU (these
			are known as </SPAN><B>Halt and Catch Fire (HCF)</B><SPAN STYLE="font-weight: normal">
			instructions.)</SPAN></FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">There
			is an instruction set for every CPU architecture. Due to the
			evolving nature of the software industry, certain trends in
			instruction sets have become common. Understanding these trends
			can help with understanding IA32 machine language.</FONT></P>
			<P><BR>
			</P>
			<H3 STYLE="margin-bottom: 0.2in">CISC and RISC</H3>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">Instruction sets typically
			fall in two categories: <B>Complex Instruction Set Computing
			(CISC)</B> <SPAN STYLE="font-weight: normal">and </SPAN><B>Reduced
			Instruction Set Computing (RISC)</B><SPAN STYLE="font-weight: normal">.
			Examples of RISC include PPC and ARM architectures. An example of
			CISC is the IA32 architecture. RISC architectures utilize a
			simplistic instruction set format over CISC. RISC architectures
			typically uses a standard encoding format for each instruction
			that allows each instruction to be of the same number of bytes.
			CISC architectures also follow a standard encoding format, but
			allows variable length instructions.</SPAN></FONT></P>
			<P><BR>
			</P>
			<H3 STYLE="margin-bottom: 0.2in">Operation code</H3>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">An <B>Operating Code
			(OPCode)</B> <SPAN STYLE="font-weight: normal">is a single byte
			identifier that the CPU utilizes to determine the instruction
			type. For example, a MOV instruction has an opcode identifier that
			lets the CPU know information about the instruction, such as type
			(MOV). Many instruction sets use opcode to distinguish one
			instruction from another. Some instructions may have </SPAN><B>multi-byte
			opcodes</B> <SPAN STYLE="font-weight: normal">and </SPAN><B>extended
			opcodes</B><SPAN STYLE="font-weight: normal">. This gives the
			instruction set more flexibility.</SPAN></FONT></P>
			<P><BR>
			</P>
			<H3 STYLE="margin-bottom: 0.2in">Addressing mode</H3>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">An
			<B>Addressing Mode</B> defines a method for the CPU to be able to
			reference <B>addresses.</B> The addresses may be virtual or
			physical depending on the architecture. Instructions, such as <B>data
			movement instructions</B>, need to be able to tell the CPU how to
			reference addresses to obtain data. For example, many CPU's
			support a <B>direct addressing mode</B> that allows an instruction
			to tell the CPU to reference (read or write) data at a specific
			address. For example, in IA32 assembly language:</FONT></P>
			<PRE STYLE="margin-bottom: 0.2in">mov eax, dword [0xa0000]</PRE><P>
			<FONT SIZE=2 STYLE="font-size: 9pt">This instruction tells the CPU
			to use the <B>direct addressing mode</B> <SPAN STYLE="font-weight: normal">to
			read from address 0xa0000 in the current address space. Another
			common addressing mode is </SPAN><B>indirect addressing</B><SPAN STYLE="font-weight: normal">,
			which allows an instruction to tell the CPU to reference data
			using a pointer. For example, in IA32 assembly language:</SPAN></FONT></P>
			<PRE STYLE="margin-bottom: 0.2in">mov eax, [ebp]</PRE><P>
			<FONT SIZE=2 STYLE="font-size: 9pt">This tells the CPU to read a
			dword from the address stored in the EBP register into the EAX
			register. There are many more addressing modes that architectures
			may utilize.</FONT></P>
			<P><BR>
			</P>
			<H1 STYLE="margin-bottom: 0.2in">IA32 and IA64 Instruction
			encoding</H1>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">We are now ready to begin
			looking at IA32 and IA64 machine instruction encoding. In order to
			save space, we will use IA64 to mean IA32 and IA64 instruction
			sets. IA32 is a subset of IA64 and thus shares a large part of the
			IA32 instruction set. The IA64 instruction set implements a CISC
			encoding. This means that each instruction follows a specific
			encoding structure and is variable in length. IA32 and IA64
			instructions can range from 1 byte to 12 bytes in size.</FONT></P>
			<P><BR>
			</P>
			<H2><B>Register codes</B></H2>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">The CPU identifies internal
			registers by a numerical value. Many registers share the same
			code; the CPU decides what register to use based on the
			instruction being used and the current operating mode (real,
			protected, or long modes). <SPAN STYLE="font-weight: normal">The
			</SPAN><B>operand size override</B> <SPAN STYLE="font-weight: normal">prefix
			is also used when determining what register to use. We will cover
			this prefix later on.</SPAN></FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><B>Register codes</B> <SPAN STYLE="font-weight: normal">are
			used in the instruction encoding to let the CPU know what
			registers the instruction operates on. The registers use the
			following codes:</SPAN></FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">REX.r
			= 0</FONT></P>
			<TABLE WIDTH=714 BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=70>
				<COL WIDTH=52>
				<COL WIDTH=59>
				<COL WIDTH=77>
				<COL WIDTH=85>
				<COL WIDTH=96>
				<COL WIDTH=87>
				<COL WIDTH=76>
				<COL WIDTH=40>
				<TR VALIGN=TOP>
					<TD WIDTH=70 BGCOLOR="#cccccc">
						<PRE>Code</PRE>
					</TD>
					<TD WIDTH=52 BGCOLOR="#cccccc" SDVAL="0" SDNUM="1033;">
						<PRE>0</PRE>
					</TD>
					<TD WIDTH=59 BGCOLOR="#cccccc" SDVAL="1" SDNUM="1033;">
						<PRE>1</PRE>
					</TD>
					<TD WIDTH=77 BGCOLOR="#cccccc" SDVAL="2" SDNUM="1033;">
						<PRE>2</PRE>
					</TD>
					<TD WIDTH=85 BGCOLOR="#cccccc" SDVAL="3" SDNUM="1033;">
						<PRE>3</PRE>
					</TD>
					<TD WIDTH=96 BGCOLOR="#cccccc" SDVAL="4" SDNUM="1033;">
						<PRE>4</PRE>
					</TD>
					<TD WIDTH=87 BGCOLOR="#cccccc" SDVAL="5" SDNUM="1033;">
						<PRE>5</PRE>
					</TD>
					<TD WIDTH=76 BGCOLOR="#cccccc" SDVAL="6" SDNUM="1033;">
						<PRE>6</PRE>
					</TD>
					<TD WIDTH=40 BGCOLOR="#cccccc" SDVAL="7" SDNUM="1033;">
						<PRE>7</PRE>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=70 BGCOLOR="#cccccc">
						<PRE>No REX
REX
REG16
REG32
REG64
MM
XMM
YMM
SSEG</PRE><P>
						<BR>
						</P>
					</TD>
					<TD WIDTH=52>
						<PRE>AL
AL
AX
EAX
RAX
MM0
XMM0
YMM0
ES
CR0
DR0</PRE>
					</TD>
					<TD WIDTH=59>
						<PRE>CL
CL
CX
ECX
RCX
MM1
XMM1
YMM1
CS
CR1
DR1</PRE>
					</TD>
					<TD WIDTH=77>
						<PRE>DL
DL
DX
EDX
RDX
MM2
XMM2
YMM2
SS
CR2
DR2</PRE>
					</TD>
					<TD WIDTH=85>
						<PRE>BL
BL
BX
EBX
RBX
MM3
XMM3
YMM3
DS
CR3
DR3</PRE>
					</TD>
					<TD WIDTH=96>
						<PRE>AH
SPL
SP
ESP
RSP
MM4
XMM4
YMM4
ES
CR4
DR4</PRE>
					</TD>
					<TD WIDTH=87>
						<PRE>CH
BPL
BP
EBP
RBP
MM5
XMM5
YMM5
GS
CR5
DR5</PRE>
					</TD>
					<TD WIDTH=76>
						<PRE>DH
SIL
SI
ESI
RSI
MM6
XMM6
YMM6

CR6
DR6</PRE>
					</TD>
					<TD WIDTH=40>
						<PRE>BH
DIL
DI
EDI
RDI
MM7
XMM7
YMM7

CR7
DR7</PRE>
					</TD>
				</TR>
			</TABLE>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">For
			example, in the instruction </SPAN><B>mov bx, 0x5</B> <SPAN STYLE="font-weight: normal">we
			would store 3 as the register code for BX. The instruction </SPAN><B>mov
			ss, ax</B> <SPAN STYLE="font-weight: normal">would require storing
			2 as the register code for SS and 0 for the register code of AX.
			Different instructions utilize different types of registers so
			there will never be a conflict between needing to choose between
			multiple registers of the same code. For example, the instruction
			</SPAN><B>mov REG16, IMM16</B> <SPAN STYLE="font-weight: normal">will
			always use a 16 bit general purpose register as an operand. For
			another example, the instruction </SPAN><B>movups xmm, xmm/m128</B>
			<SPAN STYLE="font-weight: normal">will always take an XMM register
			only.</SPAN></FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">Long
			mode adds additional registers to this list. In order to support
			the above registers, long mode has a special flag set that allows
			instructions to select other registers using the same register
			codes. This is the </SPAN><B>REX.r</B> <SPAN STYLE="font-weight: normal">field
			in the </SPAN><B>REX prefix byte</B><SPAN STYLE="font-weight: normal">
			that will be explained later on. When this bit is set, the
			register table will look like this:</SPAN></FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">REX.r=1</FONT></P>
			<TABLE WIDTH=726 BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=70>
				<COL WIDTH=50>
				<COL WIDTH=61>
				<COL WIDTH=75>
				<COL WIDTH=87>
				<COL WIDTH=95>
				<COL WIDTH=87>
				<COL WIDTH=77>
				<COL WIDTH=52>
				<TR VALIGN=TOP>
					<TD WIDTH=70 BGCOLOR="#cccccc">
						<PRE>Code</PRE>
					</TD>
					<TD WIDTH=50 BGCOLOR="#cccccc" SDVAL="0" SDNUM="1033;">
						<PRE>0</PRE>
					</TD>
					<TD WIDTH=61 BGCOLOR="#cccccc" SDVAL="1" SDNUM="1033;">
						<PRE>1</PRE>
					</TD>
					<TD WIDTH=75 BGCOLOR="#cccccc" SDVAL="2" SDNUM="1033;">
						<PRE>2</PRE>
					</TD>
					<TD WIDTH=87 BGCOLOR="#cccccc" SDVAL="3" SDNUM="1033;">
						<PRE>3</PRE>
					</TD>
					<TD WIDTH=95 BGCOLOR="#cccccc" SDVAL="4" SDNUM="1033;">
						<PRE>4</PRE>
					</TD>
					<TD WIDTH=87 BGCOLOR="#cccccc" SDVAL="5" SDNUM="1033;">
						<PRE>5</PRE>
					</TD>
					<TD WIDTH=77 BGCOLOR="#cccccc" SDVAL="6" SDNUM="1033;">
						<PRE>6</PRE>
					</TD>
					<TD WIDTH=52 BGCOLOR="#cccccc" SDVAL="7" SDNUM="1033;">
						<PRE>7</PRE>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=70 BGCOLOR="#cccccc">
						<PRE>No REX
REX
REG16
REG32
MM
XMM
YMM
SSEG</PRE>
					</TD>
					<TD WIDTH=50>
						<PRE>R8B
R8W
R8D
R8
MM0
XMM8
YMM8
ES
CR8
DR8</PRE>
					</TD>
					<TD WIDTH=61>
						<PRE>R9B
R9W
R9D
R9
MM1
XMM9
YMM9
CS
CR9
DR9</PRE>
					</TD>
					<TD WIDTH=75>
						<PRE>R10B
R10W
R10D
R10
MM2
XMM10
YMM10
SS
CR10
DR10</PRE>
					</TD>
					<TD WIDTH=87>
						<PRE>R11B
R11W
R11D
R11
MM3
XMM11
YMM11
DS
CR11
DR11</PRE>
					</TD>
					<TD WIDTH=95>
						<PRE>R12B
R12W
R12D
R12
MM4
XMM12
YMM12
FS
CR12
DR12</PRE>
					</TD>
					<TD WIDTH=87>
						<PRE>R13B
R13W
R13D
R13
MM5
XMM13
YMM13
GS
CR13
DR13</PRE>
					</TD>
					<TD WIDTH=77>
						<PRE>R14B
R14W
R14D
R14
MM6
XMM14
YMM14

CR14
DR14</PRE>
					</TD>
					<TD WIDTH=52>
						<PRE>R15B
R15W
R15D
R15
MM7
XMM15
YMM15

CR15
DR15</PRE>
					</TD>
				</TR>
			</TABLE>
			<P><BR>
			</P>
			<P><BR>
			</P>
			<H2 STYLE="margin-bottom: 0.2in">Instruction Encoding</H2>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">An IA64 instruction follows
			a well defined structure that originated from the 8085 CPU. Each
			instruction follows the following format:</FONT></P>
			<P><BR>
			</P>
			<TABLE WIDTH=773 BORDER=1 CELLPADDING=4 CELLSPACING=3>
				<COL WIDTH=114>
				<COL WIDTH=95>
				<COL WIDTH=106>
				<COL WIDTH=86>
				<COL WIDTH=49>
				<COL WIDTH=130>
				<COL WIDTH=111>
				<TR VALIGN=TOP>
					<TD WIDTH=114>
						<P>Prefix bytes (0-4) 
						</P>
					</TD>
					<TD WIDTH=95>
						<P>REX prefix (1)</P>
					</TD>
					<TD WIDTH=106>
						<P>Operation (0-3)</P>
					</TD>
					<TD WIDTH=86>
						<P>Mod R/M (1)</P>
					</TD>
					<TD WIDTH=49>
						<P>SIB (1)</P>
					</TD>
					<TD WIDTH=130>
						<P>Displacement (0-4)</P>
					</TD>
					<TD WIDTH=111>
						<P>Immediate (0-4)</P>
					</TD>
				</TR>
			</TABLE>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">For compactness, the number
			in parentheses is the number of bytes of the component. A number
			of 0 indicates that the byte is optional. For example, the <B>prefix
			bytes</B> <SPAN STYLE="font-weight: normal">can be from 0 to 4
			bytes in an instruction. This means that an instruction can have
			0, 1, 2, 3, or 4 prefix bytes. </SPAN><B>The REX prefix is only
			valid in IA64 and long modes.</B> <SPAN STYLE="font-weight: normal">The
			only required field is an </SPAN><B>operation code</B><SPAN STYLE="font-weight: normal">.
			All other fields are optional and depend on if the instruction
			requires them. For example, the </SPAN><B>INT (interrupt)</B>
			<SPAN STYLE="font-weight: normal">instruction requires an
			operation code and immediate byte while a </SPAN><B>MOV</B>
			<SPAN STYLE="font-weight: normal">instruction might utilize all of
			the above fields.</SPAN></FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">To
			provide another example, lets take a look at the INT instruction
			in more detail. The INT instruction has a form:</FONT></P>
			<PRE STYLE="margin-bottom: 0.2in; font-weight: normal">INT imm8</PRE><P STYLE="font-weight: normal">
			<FONT SIZE=2 STYLE="font-size: 9pt">where imm8 is an 8 bit
			immediate value and INT is the mnemonic for the operation code
			0xCD. Knowing the format of the instruction encoding, we can
			encode a INT 5 instruction like this:</FONT></P>
			<PRE STYLE="margin-bottom: 0.2in; font-weight: normal"><FONT COLOR="#808000">0xCD</FONT> 0x05</PRE><P>
			<FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">The
			first byte, 0xCD, is the operation code and is in </SPAN><FONT COLOR="#808000"><B>brown</B></FONT><SPAN STYLE="font-weight: normal">.
			Because prefix bytes are optional, and INT 5 does not require
			them, we do not need it. Mod R/M and SIB bytes are not needed
			either. Displacements are only used with memory a</SPAN><B>ddressing
			modes</B> <SPAN STYLE="font-weight: normal">so the only other
			field that we need is the immediate field. The immediate field is
			a 0-4 byte field. We know to use it as a 1 byte field because of
			the instruction form INT imm8. The purpose of this example is to
			demonstrate that </SPAN><B>certain fields are optional and not
			needed</B><SPAN STYLE="font-weight: normal">; the fields that are
			needed by an instruction depends on the instruction. </SPAN><B>The
			order of these fields never changes</B><SPAN STYLE="font-weight: normal">.
			For example, note above how we chose to omit the fields that are
			not needed but kept the order of the fields: the operation code
			field comes before the immediate value field. In the next few
			sections, we will cover each of these fields in more detail.</SPAN></FONT></P>
			<P><BR>
			</P>
			<H3 STYLE="margin-bottom: 0.2in"><B>Prefix fields</B></H3>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">The
			</SPAN><B>prefix bytes</B> <SPAN STYLE="font-weight: normal">allow
			an instruction to give more information to the CPU. For example,
			they allow the instruction to have the CPU lock the bus or to
			utilize a different segment register in a data movement
			instruction. Many of these prefixes have assembly language
			mnemonics. The prefix bytes are identified in 4 classes. </SPAN><B>An
			instruction can use at most 1 prefix byte from each of the 4
			classes</B><SPAN STYLE="font-weight: normal">.</SPAN></FONT></P>
			<P><BR>
			</P>
			<TABLE WIDTH=227 BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=35>
				<COL WIDTH=176>
				<TR VALIGN=TOP>
					<TD WIDTH=35 BGCOLOR="#cccccc">
						<P>Class</P>
					</TD>
					<TD WIDTH=176 BGCOLOR="#cccccc">
						<P>1 prefix</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=35 BGCOLOR="#cccccc">
						<P>0xF0</P>
					</TD>
					<TD WIDTH=176>
						<P>LOCK prefix</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=35 BGCOLOR="#cccccc">
						<P>0xF2</P>
					</TD>
					<TD WIDTH=176>
						<P>REPNE, REPNZ prefix</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=35 BGCOLOR="#cccccc">
						<P>0xF3</P>
					</TD>
					<TD WIDTH=176>
						<P>REP, REPZ, REPE prefix</P>
					</TD>
				</TR>
			</TABLE>
			<P STYLE="margin-bottom: 0.2in"><BR><BR>
			</P>
			<TABLE WIDTH=227 BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=35>
				<COL WIDTH=176>
				<TR VALIGN=TOP>
					<TD WIDTH=35 BGCOLOR="#cccccc">
						<P>Class</P>
					</TD>
					<TD WIDTH=176 BGCOLOR="#cccccc">
						<P>2 prefix</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=35 BGCOLOR="#cccccc">
						<P>0x2E</P>
					</TD>
					<TD WIDTH=176>
						<P>CS Segment override</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=35 BGCOLOR="#cccccc">
						<P>0x36</P>
					</TD>
					<TD WIDTH=176>
						<P>SS Segment override</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=35 BGCOLOR="#cccccc">
						<P>0x3E</P>
					</TD>
					<TD WIDTH=176>
						<P>DS Segment override</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=35 BGCOLOR="#cccccc">
						<P>0x26</P>
					</TD>
					<TD WIDTH=176>
						<P>ES Segment override</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=35 BGCOLOR="#cccccc">
						<P>0x64</P>
					</TD>
					<TD WIDTH=176>
						<P>FS Segment override</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=35 BGCOLOR="#cccccc">
						<P>0x65</P>
					</TD>
					<TD WIDTH=176>
						<P>GS Segment override</P>
					</TD>
				</TR>
			</TABLE>
			<P><BR>
			</P>
			<TABLE WIDTH=227 BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=36>
				<COL WIDTH=175>
				<TR VALIGN=TOP>
					<TD WIDTH=36 BGCOLOR="#cccccc">
						<P>Class</P>
					</TD>
					<TD WIDTH=175 BGCOLOR="#cccccc">
						<P>3 prefix</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=36 BGCOLOR="#cccccc">
						<P>0x66</P>
					</TD>
					<TD WIDTH=175>
						<P>Operand size override</P>
					</TD>
				</TR>
			</TABLE>
			<P><BR>
			</P>
			<TABLE WIDTH=226 BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=36>
				<COL WIDTH=174>
				<TR VALIGN=TOP>
					<TD WIDTH=36 BGCOLOR="#cccccc">
						<P>Class</P>
					</TD>
					<TD WIDTH=174 BGCOLOR="#cccccc">
						<P>4 prefix</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=36 BGCOLOR="#cccccc">
						<P>0x67</P>
					</TD>
					<TD WIDTH=174>
						<P>Address size override</P>
					</TD>
				</TR>
			</TABLE>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">We
			assume the reader knows IA32 assembly language so will omit
			describing these prefixes in detail. A machine instruction can
			only have 1 prefix byte from any of the 4 classes. Due to their
			being 4 classes, an instruction can have 0 to 4 prefix bytes. If
			an instruction attempts to use 2 or more prefix bytes from a
			single class, the CPU will throw an invalid instruction exception.</FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><B>LOCK prefix</B></FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">If
			the <B>LOCK</B> prefix is used on an instruction that does not
			support LOCK the CPU will trigger an invalid instruction
			exception. Some assemblers allow using LOCK on invalid
			instructions without giving a warning to the programmer. Due to
			this, we will present the list of valid instructions here.</FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">The
			<B>LOCK</B> prefix can only be used on the following instructions:
			ADC, ADD, AND, BTC, BTR, BTS, CMPXCHG, CMPXCHG8B, CMPXCHG16B, DEC,
			INC, NEG, NOT, OR, SBB, SUB, XADD, XCHG, and XOR.</FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><B>Operand size override</B></FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">The
			<B>operand size override </B>allows the CPU to select between 16
			bit and 32 bit operands. Assemblers typically allow the programmer
			to select a specific operand size indirectly using directives like
			<B>bits16</B> or <B>use32.</B> The IA32 and IA64 instruction sets
			provide two operand sizes: legacy 16 bit and a native size that is
			32 bit. The native size depends on the processors current
			operation mode.</FONT></P>
			<P><BR>
			</P>
			<TABLE WIDTH=425 BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=123>
				<COL WIDTH=40>
				<COL WIDTH=46>
				<COL WIDTH=54>
				<COL WIDTH=122>
				<TR VALIGN=TOP>
					<TD WIDTH=123 BGCOLOR="#cccccc">
						<P>Operation mode</P>
					</TD>
					<TD WIDTH=40 BGCOLOR="#cccccc">
						<P>CS.d</P>
					</TD>
					<TD WIDTH=46 BGCOLOR="#cccccc">
						<P>REX.w</P>
					</TD>
					<TD WIDTH=54 BGCOLOR="#cccccc">
						<P>Native</P>
					</TD>
					<TD WIDTH=122 BGCOLOR="#cccccc">
						<P>Operand override</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=123 BGCOLOR="#cccccc">
						<P>Real mode</P>
					</TD>
					<TD WIDTH=40>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=46>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=54>
						<P>16 bit</P>
					</TD>
					<TD WIDTH=122>
						<P>16 bit</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=123 BGCOLOR="#cccccc">
						<P>V8086 mode</P>
					</TD>
					<TD WIDTH=40>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=46>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=54>
						<P>16 bit</P>
					</TD>
					<TD WIDTH=122>
						<P>16 bit</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=123 BGCOLOR="#cccccc">
						<P>Protected mode</P>
					</TD>
					<TD WIDTH=40 SDVAL="0" SDNUM="1033;">
						<P>0</P>
					</TD>
					<TD WIDTH=46>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=54>
						<P>16 bit</P>
					</TD>
					<TD WIDTH=122>
						<P>32 bit</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=123 BGCOLOR="#cccccc">
						<P>Protected mode</P>
					</TD>
					<TD WIDTH=40 SDVAL="1" SDNUM="1033;">
						<P>1</P>
					</TD>
					<TD WIDTH=46>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=54>
						<P>32 bit</P>
					</TD>
					<TD WIDTH=122>
						<P>16 bit</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=123 BGCOLOR="#cccccc">
						<P>Long mode</P>
					</TD>
					<TD WIDTH=40>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=46 SDVAL="0" SDNUM="1033;">
						<P>0</P>
					</TD>
					<TD WIDTH=54>
						<P>32 bit</P>
					</TD>
					<TD WIDTH=122>
						<P>16 bit</P>
					</TD>
				</TR>
			</TABLE>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">For
			an example, lets look at the ADD AX/EAX, IMM16/IMM32 instruction.
			This instruction has operation code 0x05. In protected mode code,
			the CPU will interpret this as an ADD EAX, IMM32 instruction by
			default. However we can override the default behavior and copy a
			16 bit immediate value by using an operand override prefix. We do
			this in assembly language like this:</FONT></P>
			<PRE>add eax, 5 ; MOV EAX, IMM32
add ax, 5  ; MOV AX, IMM16</PRE><P STYLE="font-weight: normal">
			<FONT SIZE=2 STYLE="font-size: 9pt">The first instruction will
			assemble to:</FONT></P>
			<PRE STYLE="margin-bottom: 0.2in"><FONT COLOR="#808000"><B>0x05</B></FONT> <FONT COLOR="#ff3366"><B>0x05 0x00 0x00 0x00</B></FONT></PRE><P STYLE="font-weight: normal">
			<FONT SIZE=2 STYLE="font-size: 9pt">The second instruction will
			assemble to:</FONT></P>
			<PRE STYLE="margin-bottom: 0.2in; font-weight: normal"><FONT COLOR="#000000"><B>0x66</B></FONT> <FONT COLOR="#808000"><B>0x05</B></FONT><FONT COLOR="#ff3366"> </FONT><FONT COLOR="#ff3366"><B>0x05 0x00</B></FONT></PRE><P STYLE="font-weight: normal">
			<FONT SIZE=2 STYLE="font-size: 9pt">Notice the only differences
			between these two instructions are the following: (1) The first
			instruction uses a 32 bit immediate value and the second
			instruction uses a 16 bit immediate value (these are in <FONT COLOR="#ff3366"><B>red</B></FONT>),
			and (2) the second instruction uses the operand override prefix
			(this is in <B>black</B>). This tells the CPU to use the 16 bit
			operand form. For completeness, the values in <FONT COLOR="#808000"><B>brown</B></FONT>
			are the operation codes.</FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><B>Address size override</B></FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">The
			address size override prefix byte is very similar to the operand
			override prefix byte. Assemblers allow programmers to be able to
			select between address sizes by using keywords such as <B>byte ptr</B>
			and <B>dword ptr.</B> Due to the function being very similar to
			the operand override prefix, we will omit describing its purpose
			because it is the same but applies to address modes.</FONT></P>
			<P><BR>
			</P>
			<TABLE WIDTH=424 BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=124>
				<COL WIDTH=39>
				<COL WIDTH=47>
				<COL WIDTH=53>
				<COL WIDTH=121>
				<TR VALIGN=TOP>
					<TD WIDTH=124 BGCOLOR="#cccccc">
						<P>Operation mode</P>
					</TD>
					<TD WIDTH=39 BGCOLOR="#cccccc">
						<P>CS.d</P>
					</TD>
					<TD WIDTH=47 BGCOLOR="#cccccc">
						<P>REX.w</P>
					</TD>
					<TD WIDTH=53 BGCOLOR="#cccccc">
						<P>Native</P>
					</TD>
					<TD WIDTH=121 BGCOLOR="#cccccc">
						<P>Address override</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=124 BGCOLOR="#cccccc">
						<P>Real mode</P>
					</TD>
					<TD WIDTH=39>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=47>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=53>
						<P>16 bit</P>
					</TD>
					<TD WIDTH=121>
						<P>16 bit</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=124 BGCOLOR="#cccccc">
						<P>V8086 mode</P>
					</TD>
					<TD WIDTH=39>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=47>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=53>
						<P>16 bit</P>
					</TD>
					<TD WIDTH=121>
						<P>16 bit</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=124 BGCOLOR="#cccccc">
						<P>Protected mode</P>
					</TD>
					<TD WIDTH=39 SDVAL="0" SDNUM="1033;">
						<P>0</P>
					</TD>
					<TD WIDTH=47>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=53>
						<P>16 bit</P>
					</TD>
					<TD WIDTH=121>
						<P>32 bit</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=124 BGCOLOR="#cccccc">
						<P>Protected mode</P>
					</TD>
					<TD WIDTH=39 SDVAL="1" SDNUM="1033;">
						<P>1</P>
					</TD>
					<TD WIDTH=47>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=53>
						<P>32 bit</P>
					</TD>
					<TD WIDTH=121>
						<P>16 bit</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=124 BGCOLOR="#cccccc">
						<P>Long mode</P>
					</TD>
					<TD WIDTH=39>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=47 SDVAL="0" SDNUM="1033;">
						<P>0</P>
					</TD>
					<TD WIDTH=53>
						<P>64 bit</P>
					</TD>
					<TD WIDTH=121>
						<P>32 bit</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=124 BGCOLOR="#cccccc">
						<P>Long mode</P>
					</TD>
					<TD WIDTH=39>
						<P><BR>
						</P>
					</TD>
					<TD WIDTH=47 SDVAL="1" SDNUM="1033;">
						<P>1</P>
					</TD>
					<TD WIDTH=53>
						<P>64 bit</P>
					</TD>
					<TD WIDTH=121>
						<P>32 bit</P>
					</TD>
				</TR>
			</TABLE>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">For
			example, the instruction <B>mov eax, [0xa000]</B> when assembled
			in protected mode would not need an address size override. The
			assembler would treat 0xa000 as a 32 bit displacement. However, if
			we used <B>mov ax, word [0xa000]</B> the assembler would add an
			address size override prefix to the instruction to select the 16
			bit address form.</FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><B>REX prefix</B></FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">The
			REX prefix enables certain 64 bit specific features. It has the
			following format:</FONT></P>
			<PRE STYLE="font-weight: normal">| 0 | 1 | 0 | 0 | w | r | x | b |
+---+---+---+---+---+---+---+---+
7                               0</PRE>
			<TABLE WIDTH=100% BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=18*>
				<COL WIDTH=238*>
				<TR VALIGN=TOP>
					<TD WIDTH=7%>
						<P>REX.w</P>
					</TD>
					<TD WIDTH=93%>
						<P>Operand size. 0: Default, 1: 64 bit</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=7%>
						<P>REX.r</P>
					</TD>
					<TD WIDTH=93%>
						<P>ModRM.reg extension</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=7%>
						<P>REX.x</P>
					</TD>
					<TD WIDTH=93%>
						<P>SIB.index extension</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=7%>
						<P>REX.b</P>
					</TD>
					<TD WIDTH=93%>
						<P>ModRM.rm extension</P>
					</TD>
				</TR>
			</TABLE>
			<P><B>Prefix Order</B></P>
			<P>The order of the prefix bytes when used in conjunction with
			other prefix bytes does not matter. For example, you can use <B>0xF3
			0x2E</B> in the machine code to select REP and CS override. You
			can also use <B>0x2E 0xF3</B> to do the same thing.</P>
			<P><BR>
			</P>
			<H3 STYLE="margin-bottom: 0.2in">Operation code field</H3>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">The
			operation code field can be 1-3 bytes in length. All operation
			codes are unique; they identify the instruction to use and its
			operands. For example, the operation code 0 identifies the ADD
			REG/MEM8, REG8 instruction. The operation code 1 identifies an ADD
			REG/MEM16/MEM32, REG16/REG32 instruction. The IA32 and IA64 CPU
			manuals outline each instruction and their respective operation
			code.</FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><B>Primary Opcode</B></FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">The
			<B>primary opcode</B> is a single byte that is required in all
			instructions. It is the base of the operation code fields used to
			identify the instruction. The primary opcode can also take on one
			of the following formats depending on instruction.</FONT></P>
			<PRE STYLE="font-weight: normal">|   |   |   |   |   |  d | s | w |
+---+---+---+---+---+----+---+---+
7                                0

|   |   |   |   |     tttn       |
+---+---+---+---+---+----+---+---+
7                                0

|   |   |   |   |   | register ID|
+---+---+---+---+---+----+---+---+
7                                0

|   |   |   |   |   |    |   mf  |
+---+---+---+---+---+----+---+---+
7                                0</PRE>
			<TABLE WIDTH=100% BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=18*>
				<COL WIDTH=238*>
				<TR VALIGN=TOP>
					<TD WIDTH=7%>
						<P>PO.w</P>
					</TD>
					<TD WIDTH=93%>
						<P>Operand size</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=7%>
						<P>PO.s</P>
					</TD>
					<TD WIDTH=93%>
						<P>Sign extend</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=7%>
						<P>PO.d</P>
					</TD>
					<TD WIDTH=93%>
						<P>Direction</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=7%>
						<P>PO.tttn</P>
					</TD>
					<TD WIDTH=93%>
						<P>Used on some FPU instructions</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=7%>
						<P>PO.mf</P>
					</TD>
					<TD WIDTH=93%>
						<P>Memory format</P>
					</TD>
				</TR>
			</TABLE>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><B>Secondary OPCode</B></FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt"><B>When
			the primary opcode byte is 0xf0, another byte follows called the
			secondary opcode</B> byte. The secondary opcode then identifies
			different instructions and has the same functionality as above.
			These should be treated as two byte opcodes.</FONT></P>
			<P STYLE="font-weight: normal"><BR>
			</P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><B>OPCode extension</B></FONT></P>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">Certain
			families of instructions has the same opcode but differ only by a
			special field called an <B>opcode extension</B>. This is a 3 bit
			extension that is stored in the Mod R/M.reg field. The Mod R/M
			byte will be explained in more detail in the next section.</FONT></P>
			<P><BR>
			</P>
			<P><B>Multi-byte OPCodes</B></P>
			<P STYLE="font-weight: normal">The primary opcode field can be 1-3
			bytes in length. Although most instructions only use 1 byte of the
			primary opcode field, there are some that can utilize all 3 bytes.
			All of these instructions also uses a secondary opcode byte
			(0xf0).</P>
			<P><BR>
			</P>
			<H3 STYLE="margin-bottom: 0.2in">Mod R/M field</H3>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">The Mod R/M
			(Register/Memory) field is used by instructions that require
			memory or register operands. The Mod R/M field has the following
			format.</FONT></P>
			<PRE STYLE="font-weight: normal">| mod   |    reg    |    rm     |
+---+---+---+---+---+---+---+---+
7                               0</PRE><P>
			<FONT SIZE=2 STYLE="font-size: 9pt">The Mod R/M field is slightly
			different depending on if the CPU is running in real, protected or
			long modes.</FONT></P>
			<PRE STYLE="margin-bottom: 0.2in; font-weight: normal">Real mode                                            Protected and Long modes</PRE>
			<TABLE WIDTH=838 BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=100>
				<COL WIDTH=305>
				<COL WIDTH=86>
				<COL WIDTH=315>
				<TR VALIGN=TOP>
					<TD WIDTH=100>
						<P>ModRM.mod</P>
					</TD>
					<TD WIDTH=305>
						<PRE>00: [Memory]
01: [Memory+DISP8]
10: [Memory+DISP16]
11: Register</PRE>
					</TD>
					<TD WIDTH=86>
						<P><FONT SIZE=2 STYLE="font-size: 9pt">ModRM.mod</FONT></P>
					</TD>
					<TD WIDTH=315>
						<PRE>00: [Memory]
01: [Memory+DISP8]
10: [Memory+DISP32]
11: Register</PRE>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=100>
						<P>ModRM.reg</P>
					</TD>
					<TD WIDTH=305>
						<PRE>Register code</PRE>
					</TD>
					<TD WIDTH=86>
						<P><FONT SIZE=2 STYLE="font-size: 9pt">ModRM.reg</FONT></P>
					</TD>
					<TD WIDTH=315>
						<PRE>Register code</PRE>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=100>
						<P>ModRM.rm</P>
					</TD>
					<TD WIDTH=305>
						<PRE>If ModRM.mod = 11: register code
000: [BX+SI]
001: [BX+DI]
010: [BP+SI]
011: [BP+DI]
100: [SI]
101: [DI]
110: [BP] or [DISP16] when ModRM.mod=0
111: [BX]</PRE>
					</TD>
					<TD WIDTH=86>
						<P><FONT SIZE=2 STYLE="font-size: 9pt">ModRM.rm</FONT></P>
					</TD>
					<TD WIDTH=315>
						<PRE>If ModRM.mod = 11: register code
REX.b=0             REX.b=1</PRE>
						<TABLE WIDTH=273 BORDER=0 CELLPADDING=4 CELLSPACING=0>
							<COL WIDTH=150>
							<COL WIDTH=107>
							<TR VALIGN=TOP>
								<TD WIDTH=150>
									<PRE>000: [RAX]
001: [RCX]
010: [RDX]
011: [RBX]
100: [SIB]
101: [RBP][DISP32]
110: [RSI]
111: [RDI]</PRE>
								</TD>
								<TD WIDTH=107>
									<PRE>000: [R8]
001: [R9]
010: [R10]
011: [R11]
100: [SIB]
101: [DISP32]
110: [R14]
111: [R15]</PRE>
								</TD>
							</TR>
						</TABLE>
						<PRE></PRE>
					</TD>
				</TR>
			</TABLE>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">The ModRM.mod field is
			combined with Mod.rm field to determine the addressing mode. For
			example, the <SPAN STYLE="font-weight: normal">instruction </SPAN><B>mov
			ax, [0xa000]</B> <SPAN STYLE="font-weight: normal">would use (in
			real mode) ModRM.mod = 0 (Memory) and ModRM.rm = 6 (DISP16).
			ModRM.reg would contain the register code for AX. If we are to use
			</SPAN><B>mov ax, [bx+0xa000]</B> <SPAN STYLE="font-weight: normal">instead,
			ModRM would be 2 (Memory+DISP16) and ModRM.rm would be 7.
			Assemblers would treat 0xa000 here as a DISP16 rather then a DISP8
			due to 0xa000 being a word size displacement. We can select the
			DISP8 form by using an </SPAN><B>address size override</B> <SPAN STYLE="font-weight: normal">prefix.</SPAN></FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">Looking
			at the above tables we can deduce that there is not many registers
			can be used for indirect addressing. For example, </SPAN><B>[BP]</B>
			<SPAN STYLE="font-weight: normal">is not a valid addressing mode,
			but assemblers can assemble this fine in instructions like </SPAN><B>mov
			ax, [bp]</B><SPAN STYLE="font-weight: normal">. A common trick
			used by these assemblers is to set ModRM.mod = 1 (Memory+DISP8)
			and ModRM.rm = 6 (BP). In other words, the assemblers translate
			this into a </SPAN><B>[BP+DISP8]</B> <SPAN STYLE="font-weight: normal">addressing
			mode, setting the displacement to 0. So </SPAN><B>mov ax, [bp]</B>
			<SPAN STYLE="font-weight: normal">is assembled into </SPAN><B>mov
			ax, [bp+0]</B><SPAN STYLE="font-weight: normal">.</SPAN></FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">Protected
			and long modes introduce another addressing mode, </SPAN></FONT><FONT SIZE=2 STYLE="font-size: 9pt"><B>[SIB]</B></FONT><FONT SIZE=2 STYLE="font-size: 9pt">
			</FONT><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">which
			gives more capabilities. SIB addressing modes can be combined with
			ModRM.rm modes. For example, in protected mode, </SPAN></FONT><FONT SIZE=2 STYLE="font-size: 9pt"><B>mov
			eax, [ebx+edi*2+0xa000]</B></FONT><FONT SIZE=2 STYLE="font-size: 9pt">
			</FONT><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">would
			be translated to ModRM.mod = 2 (Memory+DISP32) and ModRM.rm = 4
			(SIB byte). The SIB byte tells us how to extract the </SPAN></FONT><FONT SIZE=2 STYLE="font-size: 9pt"><B>edx+edi*2</B></FONT><FONT SIZE=2 STYLE="font-size: 9pt">
			</FONT><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">in
			this instruction so will be explained in the next section.</SPAN></FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">Certain
			instructions utilize an </SPAN></FONT><FONT SIZE=2 STYLE="font-size: 9pt"><B>extended
			opcode</B></FONT><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">
			field. Extended opcodes are identifiers that are used with the
			</SPAN></FONT><FONT SIZE=2 STYLE="font-size: 9pt"><B>primary
			opcode</B></FONT><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">
			when identifying instructions. This is a 3 bit field and is stored
			in Mod R/M.reg field for these instructions. Instructions that use
			an extended opcode field might still use ModRM.rm and ModRM.mod to
			store a register operand or memory addressing mode.</SPAN></FONT></P>
			<P><BR>
			</P>
			<H3><B>SIB field</B></H3>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">The
			</SPAN><B>Scale Index Base (SIB)</B> <SPAN STYLE="font-weight: normal">byte
			</SPAN><B>follows a Mod R/M byte only if Mod R/M.rm = 4 and the
			CPU is in protected or long modes</B><SPAN STYLE="font-weight: normal">.
			The byte provides additional addressing modes to the IA32 and IA64
			architectures. SIB addressing is combined with Mod R/M addressing
			in order to create a wide array of additional addressing modes.</SPAN></FONT></P>
			<PRE STYLE="font-weight: normal">| Scale |   Index   |   Base    |
+---+---+---+---+---+---+---+---+
7                               0</PRE><P>
			<BR>
			</P>
			<TABLE WIDTH=490 BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=69>
				<COL WIDTH=405>
				<TR VALIGN=TOP>
					<TD WIDTH=69>
						<P>SIB.Scale</P>
					</TD>
					<TD WIDTH=405>
						<PRE>00: Factor 1
01: Factor 2
10: Factor 4
11: Factor 8</PRE>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=69>
						<P>SIB.Index</P>
					</TD>
					<TD WIDTH=405>
						<PRE>Uses standard register codes
If VSIB, uses VR register codes
If REX.x = 1, uses 64 bit register codes
If REX.x = 1 and VSIB, uses VR register codes</PRE>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=69>
						<P>SIB.Base</P>
					</TD>
					<TD WIDTH=405>
						<PRE>Uses standard register codes
If REX.b=1, uses 64 bit register codes</PRE>
					</TD>
				</TR>
			</TABLE>
			<P STYLE="font-weight: normal"><FONT SIZE=2 STYLE="font-size: 9pt">Despite
			the names of the register fields in the SIB byte, you can
			technically use any register code. For example, you can put an
			index register in SIB.Base.</FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">Lets
			combine the SIB byte with Mod R/M again to demonstrate how they
			work together. Using our previous example, </SPAN><B>mov eax,
			[ebx+edi*2+0xa000]</B><SPAN STYLE="font-weight: normal">. We
			assume the CPU is running in protected mode for this example. EAX
			is the non-memory register, so that will be in Mod R/M.reg. We
			also have to set Mod R/M.mod = 2 to enable [Memory+DISP32] and Mod
			R/M.rm = 4 [SIB byte]. </SPAN><B>ebx</B> <SPAN STYLE="font-weight: normal">is
			our base register, </SPAN><B>edi</B> <SPAN STYLE="font-weight: normal">is
			our index register. The </SPAN><B>register code</B> <SPAN STYLE="font-weight: normal">for
			EBX is 3 and the </SPAN><B>register code</B> <SPAN STYLE="font-weight: normal">for
			EDI is 7. Using this, we can set SIB.index = 7 and SIB.base = 3.
			The scale factor, </SPAN><B>2</B> <SPAN STYLE="font-weight: normal">goes
			into SIB.scale.</SPAN></FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">Putting
			this together, we have a Mod R/M byte of </SPAN><B>10 000 100
			binary</B> <SPAN STYLE="font-weight: normal">and an SIB byte of </SPAN><B>10
			111 011 binary</B><SPAN STYLE="font-weight: normal">. Knowing we
			have a 32 bit displacement of </SPAN><B>0xa000</B> <SPAN STYLE="font-weight: normal">and
			the operation code being </SPAN><B>0x89</B><SPAN STYLE="font-weight: normal">,
			we can translate our example instruction into:</SPAN></FONT></P>
			<PRE STYLE="margin-bottom: 0.2in; font-weight: normal"><FONT COLOR="#808000">0x89</FONT> <FONT COLOR="#ff3366">0x84 0xbb</FONT> 0x00 0xa0 0x00 0x00</PRE><P>
			<FONT SIZE=2 STYLE="font-size: 9pt"><FONT SIZE=2><SPAN STYLE="font-weight: normal">This
			would be the correct translation of </SPAN></FONT><FONT SIZE=2><B>mov
			eax, [ebx+edi*2+0xa000]</B></FONT><FONT SIZE=2><SPAN STYLE="font-weight: normal">.
			To ease readability, the operation code is in </SPAN></FONT><FONT COLOR="#808000"><FONT SIZE=2><B>brown</B></FONT></FONT><FONT SIZE=2><SPAN STYLE="font-weight: normal">,
			Mod R/M and SIB bytes are in </SPAN></FONT><FONT COLOR="#ff3366"><FONT SIZE=2><B>red</B></FONT></FONT><FONT SIZE=2><SPAN STYLE="font-weight: normal">,
			and the displacement field is in </SPAN></FONT><FONT SIZE=2><B>black</B></FONT><FONT SIZE=2><SPAN STYLE="font-weight: normal">.
			Note that this follows the exact format of an instruction: first
			is the primary opcode, next is the Mod R/M byte, next is the SIB
			byte, and the displacement byte follows.</SPAN></FONT></FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">If
			the displacement byte in the above instruction looks odd, please
			consider that the IA32 and IA64 architectures are </SPAN><B>little
			endian</B><SPAN STYLE="font-weight: normal">.</SPAN></FONT></P>
			<P><BR>
			</P>
			<H3 STYLE="margin-bottom: 0.2in">Displacement field</H3>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">The displacement field is
			only valid if Mod R/M.mod is mode 1 (Memory+DISP8) or mode 2
			(Memory+DISP16 or Memory+DISP32). The displacement can be a byte,
			word or dword value and is used in conjunction with the Mod R/M
			and SIB bytes to add displacements to addressing modes. The
			displacement field always follows the Mod R/M or SIB byte.</FONT></P>
			<P><BR>
			</P>
			<H3 STYLE="margin-bottom: 0.2in">Immediate field</H3>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">The immediate field is only
			valid if the instruction requires it as an operand. Instructions
			might require an 8, 16, or 32 bit immediate value. This field must
			then be present as the last field in the instruction. Instructions
			that allow both 16 and 32 bit values depend on if an <B>operand
			override size</B> <SPAN STYLE="font-weight: normal">prefix is
			present to determine the size of this field.</SPAN></FONT></P>
			<P STYLE="font-weight: normal"><BR>
			</P>
			<H1><B>Instruction tables</B></H1>
			<P><FONT SIZE=2 STYLE="font-size: 9pt"><SPAN STYLE="font-weight: normal">An
			</SPAN><B>instruction look-up table</B><SPAN STYLE="font-weight: normal">
			is utilized by certain software to help facilitate the machine
			language translation of instructions. The tables reflect that of a
			generic instruction table that provides all of the operational
			codes and operand types for all of the instructions. We can use a
			resource, such as the IA32 manuals or an online reference, to
			construct the tables or to help with building machine
			instructions. The design of these tables varies considerably; it
			is important to read the documentation on how to read these
			look-up tables.</SPAN></FONT></P>
			<P><FONT SIZE=2 STYLE="font-size: 9pt">The tables would present an
			instruction in a form similar to the following.</FONT></P>
			<PRE>| 0x10 | ADC | R/MEM8 | R8 |
+------+-----+--------+----+</PRE><P>
			This represents an ADC instruction whose operation code is 0x10.
			The R/MEM8 is the first operand, and R8 is the second operand.
			Operands can be represented in different ways depending on the
			tables' design. The table may also present additional information
			such as effected flags the instruction sets, what form of the
			opcode byte the instruction might use (such as if it stores a
			register ID in the opcode field), supported processors, and so on.
			These tables can get really large in size but they all provide the
			same basic information typically presented in the above form.</P>
			<P>R/MEM8 in the above means that the first operand is a
			&ldquo;register&rdquo; or &ldquo;8 bit memory location&rdquo;. The
			&ldquo;R8&rdquo; means the second operand is an 8 bit register. <B>If
			an instruction has a memory operand, then a Mod R/M (and possibly
			an SIB byte) must follow</B>. Also, <B>if an instruction takes two
			register operands, a Mod R/M byte must follow</B>. The Mod R/M
			byte will store the memory addressing mode information or both
			register codes in Mod R/M.rm and Mod R/M.reg. The CPU will know
			the register code is for an 8 bit register because of the opcode.
			<B>The</B> <B>opcode tells the CPU not only what instruction to
			execute, but also what operands the instruction requires</B>. An
			instruction may utilize different types of operands, because of
			this the same instruction can occupy multiple opcodes. For
			example, the above instruction form uses opcode 0x10. Other forms
			include but are not limited to the following.</P>
			<PRE>| 0x11 | ADC | R/MEM16/MEM32 | R16/REG32     |
+------+-----+---------------+---------------+
| 0x12 | ADC | R8            | R/REG16/REG32 |
+------+-----+---------------+---------------+
| 0x13 | ADC | R16/REG32     | R/MEM16/MEM32 |
+------+-----+---------------+---------------+</PRE><P>
			If an instruction uses an operand like <B>REG16/REG32</B>, you
			need to deduce the operand to use based on if an <B>operand size
			override</B><SPAN STYLE="font-weight: normal"> prefix is present
			and the current CPU operation mode (that is, if it is running in
			protected mode, real mode, long mode, and so on). For example, if
			the instruction is an </SPAN><B>ADC ax, word ptr [0] </B><SPAN STYLE="font-weight: normal">and
			we are running this in protected mode (or, in assembly language
			terminology, we used </SPAN><B>bits32</B><SPAN STYLE="font-weight: normal">
			or </SPAN><B>use32</B><SPAN STYLE="font-weight: normal">
			directives), we can use opcode 0x13 for the instruction. We know
			this instruction takes the form </SPAN><B>ADC REG16, MEM16/MEM32</B><SPAN STYLE="font-weight: normal">.
			AX is the first operand, which is a 16 bit register (REG16). But
			what is [0]? In order to find out, we take into consideration that
			there is no address size override and that we are in protected
			mode. Due to there being no address size override we are to use
			the native size, which is 32 bit memory addressing. (Please see
			the section on the address size override prefix for more
			information.) Using this, we conclude that we select the </SPAN><B>ADC
			REG16, MEM32</B><SPAN STYLE="font-weight: normal"> form. (If an
			address size override did exist, we would select the ADC REG16,
			MEM16 form).</SPAN></P>
			<P><SPAN STYLE="font-weight: normal">If an instruction only has a
			single register operand, verify if the operand is stored in the
			OPCode.reg field. (Please see the Operational code section for
			more information.) Some instructions do this to save space, </SPAN><B>this
			is what allows single byte instructions</B><SPAN STYLE="font-weight: normal">.
			Some instructions might utilize two registers for operands storing
			them in OPCode.reg and Mod R/M.reg or Mod R/M.rm.</SPAN></P>
			<P><SPAN STYLE="font-weight: normal">To complete this example, we
			note the following: OPCode 0x13, AX register code (0), Addressing
			mode is [Memory] with a displacement of 0. Due to is being in
			protected mode, we use the 32 bit Mod R/M form. Mod R/M.reg = 0
			(selecting AX), Mod R/M.rm = 5 (DISP32) and Mod R/M.mod = 0
			([MEMORY]). This creates a Mod R/M value of </SPAN><B>00 000 101
			binary</B><SPAN STYLE="font-weight: normal">. Due to us not using
			a [SIB] mode, we do not need to use an SIB byte. (For an example
			that does use the SIB, please see our previous example for
			disassembling </SPAN><FONT SIZE=2><B>mov eax, [ebx+edi*2+0xa000]</B></FONT><FONT SIZE=2><SPAN STYLE="font-weight: normal">).
			Using this information, we can build the machine code.</SPAN></FONT></P>
			<PRE><FONT SIZE=3><FONT COLOR="#280099">0x66</FONT><FONT COLOR="#808000"> 0x13</FONT><SPAN STYLE="font-weight: normal"> </SPAN><FONT COLOR="#ff3366">0x05</FONT><SPAN STYLE="font-weight: normal"> 0x00 0x00 0x00 0x00</SPAN></FONT></PRE><P>
			<SPAN STYLE="font-weight: normal">The OPCode is in </SPAN><FONT COLOR="#808000"><B>brown</B></FONT><SPAN STYLE="font-weight: normal">
			and Mod R/M byte is in </SPAN><FONT COLOR="#ff3366"><B>red</B></FONT><SPAN STYLE="font-weight: normal">.
			The displacement byte is a DISP32 (due to Mod R/M.rm) so must be a
			dword. This is identified in </SPAN><B>black</B><SPAN STYLE="font-weight: normal">.
			The 0x66 is an </SPAN><B>operand size override prefix</B><SPAN STYLE="font-weight: normal">
			which is in </SPAN><FONT COLOR="#280099"><B>blue</B></FONT><SPAN STYLE="font-weight: normal">.
			We use an operand override size prefix in order to select the
			REG16 and MEM16 form rather then the REG32 and MEM32 form. If we
			omit the prefix, we will get the following instead.</SPAN></P>
			<PRE><FONT SIZE=3>0x13<SPAN STYLE="font-weight: normal"> </SPAN>0x05<SPAN STYLE="font-weight: normal"> 0x00 0x00 0x00 0x00</SPAN></FONT></PRE><P>
			In protected mode, this is an <B>adc eax, dword ptr [0]</B>
			instruction which was not what we wanted. Please see the operand
			size override prefix section for more information.</P>
			<P>If we wanted to turn <B>ADC ax, word ptr [0] </B><SPAN STYLE="font-weight: normal">into</SPAN><B>
			REP ADC ax, word ptr ES:[0] </B><SPAN STYLE="font-weight: normal">we
			can use an ES override prefix and REP prefix:</SPAN></P>
			<PRE><FONT SIZE=3><FONT COLOR="#808000">0xf3 0x26 0x66 0x13</FONT> <FONT COLOR="#ff3366">0x05</FONT> 0x00 0x00 0x00 0x00</FONT></PRE><P>
			The order of the prefix bytes do not matter.</P>
			<H1></H1>
			<P STYLE="margin-bottom: 0in"><BR>
			</P>
			<H1><B>Resources</B></H1>
			<P STYLE="margin-bottom: 0in; font-weight: normal">The following
			resources are presented for supplemental reading. Please note that
			we do not provide support for these resources.</P>
			<TABLE WIDTH=100% BORDER=0 CELLPADDING=4 CELLSPACING=0>
				<COL WIDTH=96*>
				<COL WIDTH=160*>
				<TR VALIGN=TOP>
					<TD WIDTH=38%>
						<P><A HREF="http://ref.x86asm.net/"><SPAN STYLE="font-weight: normal">http://ref.x86asm.net/</SPAN></A><SPAN STYLE="font-weight: normal">
						</SPAN>
						</P>
					</TD>
					<TD WIDTH=62%>
						<P STYLE="font-weight: normal">IA32 and IA64 instruction table</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=38%>
						<P><A HREF="http://www.sandpile.org/">http://www.sandpile.org/</A>
												</P>
					</TD>
					<TD WIDTH=62%>
						<P>Instruction format tables</P>
					</TD>
				</TR>
				<TR VALIGN=TOP>
					<TD WIDTH=38%>
						<P><A HREF="http://wiki.osdev.org/X86-64_Instruction_Encoding">http://wiki.osdev.org/X86-64_Instruction_Encoding</A>
												</P>
					</TD>
					<TD WIDTH=62%>
						<P>IA32 and IA64 Instruction encoding</P>
					</TD>
				</TR>
			</TABLE>
			<P STYLE="margin-bottom: 0in"><BR>
			</P>
			<H1 STYLE="margin-bottom: 0.2in">Conclusion</H1>
			<P>This chapter provided an overview of machine language
			programming and the instruction encoding on IA32 and IA64
			architectures. A goal of this chapter is to present the material
			in a new way to encourage the development of debuggers and
			tool-chains. This chapter can also be used as a reference with an
			instruction table when emulating certain instructions.</P>
			<P>Please let me know if there are any questions or comments,</P>
			<P>~Mike ();</P>
			<P>OS Development Series Editor</P>
		</TD>
	</TR>
</TABLE>
<P><BR><BR>
</P>
</BODY>
</HTML>