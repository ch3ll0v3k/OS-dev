<html>
<head>
   <title>Interfacing The PC : Using Interrupts </title>
   <META name="description" content="Info on Programming and Implementing IRQ's. Includes IRQ2-9 Redirection, 8259 Registers and Sample Code in C.">
   <META name="keywords" content="PIC, Interrupts, Interrupt Service Routines, 8259, ISR, IRQ">
</head>
<body background="/background.gif">

<STYLE TYPE="text/css">
#TITLEBLOCK { text-decoration: none; color:#FFFFFF }
TD,P,FONT {font-family : Arial}
</STYLE>

<CENTER>
 <BR>
 <BR>
 <a href="http://www.beyondlogic.org"><img src="/interface.gif" alt="Interfacing the PC / Beyond Logic" border=0></a>
 <BR>
 <TABLE WIDTH="70%">
 <TR><TD>
 <DIV ALIGN=RIGHT><FONT SIZE=+1 FACE=ARIAL>Quality Information in one Place . . .</FONT></DIV>
 </TD></TR></TABLE>
 <BR>
<TABLE WIDTH="90%" BORDER=0>
<TR>
<TD BGCOLOR=BLUE HEIGHT=25 WIDTH="20%"><FONT FACE=ARIAL COLOR=WHITE><B><CENTER><A ID="TITLEBLOCK" HREF="/index.html#PARALLEL">Parallel Ports</a></CENTER></B></FONT></TD>
<TD BGCOLOR=BLUE HEIGHT=25 WIDTH="20%"><FONT FACE=ARIAL COLOR=WHITE><B><CENTER><A ID="TITLEBLOCK" HREF="/index.html#SERIAL">Serial Ports</a></CENTER></B></FONT></TD>
<TD BGCOLOR=BLUE HEIGHT=25 WIDTH="20%"><FONT FACE=ARIAL COLOR=WHITE><B><CENTER><A ID="TITLEBLOCK" HREF="/index.html#INTERRUPTS">Interrupts</a></CENTER></B></FONT></TD>
<TD BGCOLOR=BLUE HEIGHT=25 WIDTH="20%"><FONT FACE=ARIAL COLOR=WHITE><B><CENTER><A ID="TITLEBLOCK" HREF="/index.html#ATKEYBOARDS">AT Keyboard Ports</a></CENTER></B></FONT></TD>
<TD BGCOLOR=BLUE HEIGHT=25 WIDTH="20%"><FONT FACE=ARIAL COLOR=WHITE><B><CENTER><A ID="TITLEBLOCK" HREF="/index.html#USB">USB</a></CENTER></B></FONT></TD>
</TR>
</TABLE>
<br>
<HR><font SIZE=5>Using Interrupts</font><HR></center>

<CENTER><FONT SIZE=+1>Interrupts</FONT></CENTER> 
<CENTER><A HREF="#1">What are Interrupts?</A></CENTER>
<CENTER><A HREF="#2">Interrupts and Intel Architecture</A></CENTER>
<CENTER><A HREF="#3">Hardware Interrupts</A></CENTER>
<CENTER><FONT SIZE=+1>Programming</FONT></CENTER> 
<CENTER><A HREF="#4">Implementing the Interrupt Service Routine (ISR)</A></CENTER>
<CENTER><A HREF="#5">Using your new Interrupt Service Routine</A></CENTER>
<CENTER><FONT SIZE=+1>The Programmable Interrupt Controller's Operation</FONT></CENTER> 
<CENTER><A HREF="#6">The Programmable Interrupt Controller</A></CENTER>
<CENTER><A HREF="#7">IRQ2/IRQ9 Redirection</A></CENTER>
<CENTER><FONT SIZE=+1>The Programmable Interrupt Controller's Registers</FONT></CENTER> 
<CENTER><A HREF="#8">Programmable Interrupt Controller's Addresses</A></CENTER>
<CENTER><A HREF="#9">Initialization Command Words (ICWs)</A></CENTER>
<CENTER><A HREF="#13">Operation Control Words (OCWs)</A></CENTER>
<CENTER><FONT SIZE=+1>Feedback</FONT></CENTER> 
<CENTER><A HREF="#16">Feedback</A></CENTER>
<BR>

<UL>
<A NAME="1"></A>
<HR width="100%"><I><FONT SIZE=+2>What are Interrupts?</FONT></I>
<HR width="100%">
<p>
When receiving data and change in status from I/O Ports, we have two methods
available to us. We can <i>Poll</I> the port, which involves reading the
status of the port at fixed intervals to determine whether any data has been
received or a change of status has occurred. If so, then we can branch to a
routine to service the ports requests.
</P>
<p>
As you could imagine, polling the port would consume quite some time. Time
which could be used doing other things such refreshing the screen, displaying
the time etc. A better alternative would be to use <I>Interrupts</I>. Here,
the processor does your tasks such as refreshing the screen, displaying the
time etc, and when a I/O Port/Device needs attention as a byte has been
received or status has changed, then it sends a Interrupt Request (IRQ)
to the processor.
</P>
<p>
Once the processor receives an Interrupt Request, it finishes its current
instruction, places a few things on the stack, and executes the appropriate
Interrupt Service Routine (ISR) which can remove the byte from the port and
place it in a buffer. Once the ISR has finished, the processor returns to
where it left off.
</P>
<p>
Using this method, the processor doesn't have to waste time, looking to see
if your I/O Device is in need of attention, but rather the device will
<i>interrupt</I> the processor when it needs attention.
</P>

<A NAME="2"></A>
<HR width="100%"><I><FONT SIZE=+2>Interrupts and Intel Architecture</FONT></I>
<HR width="100%">
<p>
Interrupts do not have to be entirely associated with I/O devices. The 8086
family of microprocessors provides 256 interrupts, many of these are only
for use as software interrupts, which we do not attempt to explain in this
document.
</P>
<P>
The 8086 series of microprocessors has an Interrupt Vector Table situated at
0000:0000 which extends for 1024 bytes. The Interrupt Vector table holds the
address of the Interrupt Service Routines (ISR), all four bytes in length.
This gives us room for the 256 Interrupt Vectors.
</P>

<center>
<table border width="80%">
<TR><TD><center><B>INT (Hex)</B></center></TD><TD><b><center>IRQ</center></B></TD><TD><b>Common Uses</b></TD></TR>
<TR><TD><center>00 - 01</center></TD><TD><center>Exception Handlers</center></TD><TD><center>-</Center></TD></TR>
<TR><TD><center>02</center></TD><TD><center>Non-Maskable IRQ</center></TD><TD>Non-Maskable IRQ (Parity Errors)</TD></TR>
<TR><TD><center>03 - 07</center></TD><TD><center>Exception Handlers</center></TD><TD><center>-</center></TD></TR>
<TR><TD><center>08</center></TD><TD><center>Hardware IRQ0</center></TD><TD>System Timer</TD></TR>
<TR><TD><center>09</center></TD><TD><center>Hardware IRQ1</center></TD><TD>Keyboard</TD></TR>
<TR><TD><center>0A</center></TD><TD><center>Hardware IRQ2</center></TD><TD>Redirected</TD></TR>
<TR><TD><center>0B</center></TD><TD><center>Hardware IRQ3</center></TD><TD>Serial Comms. COM2/COM4</TD></TR>
<TR><TD><center>0C</center></TD><TD><center>Hardware IRQ4</center></TD><TD>Serial Comms. COM1/COM3 </TD></TR>
<TR><TD><center>0D</center></TD><TD><center>Hardware IRQ5</center></TD><TD>Reserved/Sound Card </TD></TR>
<TR><TD><center>0E</center></TD><TD><center>Hardware IRQ6</center></TD><TD>Floppy Disk Controller </TD></TR>
<TR><TD><center>0F</center></TD><TD><center>Hardware IRQ7</center></TD><TD>Parallel Comms. </TD></TR>
<TR><TD><center>10 - 6F</center></TD><TD><center>Software Interrupts</center></TD><TD><center>-</center></TD></TR>
<TR><TD><center>70</center></TD><TD><center>Hardware IRQ8</center></TD><TD>Real Time Clock</TD></TR>
<TR><TD><center>71</center></TD><TD><center>Hardware IRQ9</center></TD><TD>Redirected IRQ2</TD></TR>
<TR><TD><center>72</center></TD><TD><center>Hardware IRQ10</center></TD><TD>Reserved</TD></TR>
<TR><TD><center>73</center></TD><TD><center>Hardware IRQ11</center></TD><TD>Reserved</TD></TR>
<TR><TD><center>74</center></TD><TD><center>Hardware IRQ12</center></TD><TD>PS/2 Mouse</TD></TR>
<TR><TD><center>75</center></TD><TD><center>Hardware IRQ13</center></TD><TD>Math's Co-Processor</TD></TR>
<TR><TD><center>76</center></TD><TD><center>Hardware IRQ14</center></TD><TD>Hard Disk Drive</TD></TR>
<TR><TD><center>77</center></TD><TD><center>Hardware IRQ15</center></TD><TD>Reserved </TD></TR>
<TR><TD><center>78 - FF</center></TD><TD><center>Software Interrupts</center></TD><TD><center>-</center></TD></TR>
</Table>
<font size =-1> Table 1 : x86 Interrupt Vectors </Font>
</center>
<p>
The average PC, only has 15 Hardware IRQ's plus one Non-Maskable IRQ. The
rest of the interrupt vectors are used for software interrupts and exception
handlers. Exception handlers are routines like ISR's which get called or
<I>interrupted</I> when an error results. Such an example is the first
Interrupt Vector which holds the address of the Divide By Zero, Exception
handler. When a divide by zero occurs the Microprocessor fetches the
address at 0000:0000 and starts executing the code at this Address.
</P>



<A NAME="3"></A>
<HR width="100%"><I><FONT SIZE=+2>Hardware Interrupts</FONT></I>
<HR width="100%">
<P>
The Programmable Interrupt Controller (PIC) handles hardware interrupts. Most
PC's will have two of them located at different addresses. One handles IRQ's
0 to 7 and the other, IRQ's 8 to 15, giving a total of 15 individual IRQ lines,
as the second PIC is cascaded into the first, using IRQ2.
</P>

<P>
Most of the PIC's initialization is done by BIOS, thus we only have to worry
about two instructions. The PIC has a facility available where we can <I>
mask</I> individual IRQ's so that these requests will not reach the Processor.
Thus the first instruction is to the
<a href="#13">Operation Control Word 1 (OCW1)</A> to
set which IRQ's to mask and which IRQ's not too.
</P>

<P>
As there are two PIC's located at different addresses, we must first
determine which PIC we need to use. The first PIC, located at Base Address
0x20h controls IRQ 0 to IRQ 7. The bit format of PIC1's Operation Control
Word 1 is shown below in table 2.
</P>

<center>
<Table border width="80%">
<TR><TD><Center><B>Bit</B></Center></TD><TD><Center><B>Disable IRQ</B></Center></TD><TD><center><B>Function</B></center></TD></TR>
<TR><TD><CENTER>7</CENTER></TD><TD><Center>IRQ7</center></TD><TD>Parallel Port</TD></TR>
<TR><TD><CENTER>6</CENTER></TD><TD><Center>IRQ6</center></TD><TD>Floppy Disk Controller</TD></TR>
<TR><TD><CENTER>5</CENTER></TD><TD><Center>IRQ5</center></TD><TD>Reserved/Sound Card</TD></TR>
<TR><TD><CENTER>4</CENTER></TD><TD><Center>IRQ4</center></TD><TD>Serial Port</TD></TR>
<TR><TD><CENTER>3</CENTER></TD><TD><Center>IRQ3</center></TD><TD>Serial Port</TD></TR>
<TR><TD><CENTER>2</CENTER></TD><TD><Center>IRQ2</center></TD><TD>PIC2</TD></TR>
<TR><TD><CENTER>1</CENTER></TD><TD><Center>IRQ1</center></TD><TD>Keyboard</TD></TR>
<TR><TD><CENTER>0</CENTER></TD><TD><Center>IRQ0</center></TD><TD>System Timer</TD></TR>
</table>
<font size=-1>Table 2 : PIC1 Operation Control Word 1 (0x21)</FONT>
</center>

<P>
<i>
Note that IRQ 2 is connected to PIC2, thus if you mask this IRQ, then you
will be disabling IRQ's 8 to 15.
</I>
</P>

<P>
The second PIC located at a base address of 0xA0h controls IRQs 8 to 15.
Below is the individual bits required to make up it's Operation Control
Word.
</P>

<center>
<Table border width="80%">
<TR><TD><Center><B>Bit</B></Center></TD><TD><Center><B>Disable IRQ</B></Center></TD><TD><center><B>Function</B></center></TD></TR>
<TR><TD><CENTER>7</CENTER></TD><TD><Center>IRQ15</center></TD><TD>Reserved</TD></TR>
<TR><TD><CENTER>6</CENTER></TD><TD><Center>IRQ14</center></TD><TD>Hard Disk Drive</TD></TR>
<TR><TD><CENTER>5</CENTER></TD><TD><Center>IRQ13</center></TD><TD>Maths Co-Processor</TD></TR>
<TR><TD><CENTER>4</CENTER></TD><TD><Center>IRQ12</center></TD><TD>PS/2 Mouse</TD></TR>
<TR><TD><CENTER>3</CENTER></TD><TD><Center>IRQ11</center></TD><TD>Reserved</TD></TR>
<TR><TD><CENTER>2</CENTER></TD><TD><Center>IRQ10</center></TD><TD>Reserved</TD></TR>
<TR><TD><CENTER>1</CENTER></TD><TD><Center>IRQ9</center></TD><TD>Redirected IRQ2</TD></TR>
<TR><TD><CENTER>0</CENTER></TD><TD><Center>IRQ8</center></TD><TD>Real Time Clock</TD></TR>
</table>
<font size=-1>Table 3 : PIC2 Operation Control Word 1 (0xA1) </FONT>
</center>

<P>
As the above table shows the bits required to disable an IRQ, we must
invert them should we want to enable an IRQ. For example, if we want to
enable IRQ 3 then we would send the byte 0xF7 as OCW1 to PIC1. But what
happens if one of these IRQs are already enabled and then we come
along and disable it?
</P>

<P>
Therefore we must first get the mask and use the AND function to output the
byte back to the register with our changes so to cause the least upset to
the other IRQs. Going back to our IRQ3 example, we could use
<font color="#400080"><TT>outportb(0x21,(inportb(0x21) & 0xF7);</TT></FONT>
to enable IRQ3. Take note that the OCW1 goes to the register at Base + 1.
</P>

<p>
The same procedure must be used to mask (disable) an IRQ once we are finished with it.
However this time we must OR the byte 0x08 to the contents of OCW1. Such
and example of code is
<font color="#400080"><TT>outportb(0x21,(inportb(0x21) | 0x08);</TT></FONT>
</P>

<P>
The other PIC instruction we have to worry about is the End of Interrupt (EOI).
This is sent to the PIC at the end of the Interrupt Service Routine so that
the PIC can reset the In Service Register. See <a href="#6">The Programmable
Interrupt Controller</A> for more information. An EOI can be sent using
<font color="#400080"><TT>outportb(0x20,0x20);</TT></FONT> for PIC1 or
<font color="#400080"><TT>outportb(0xA0,0x20);</TT></FONT> for PIC2
</P>

<A NAME="4"></A>
<HR width="100%"><I><FONT SIZE=+2>Implementing the Interrupt Service Routine (ISR)</FONT></I>
<HR width="100%">

<P>
In C you can implement your ISR using
<font color="#400080"><TT>void interrupt yourisr()</TT></font> where
<TT>yourisr</TT> is a far pointer, pointing to the address that your
Interrupt Service Routine will reside in memory. This is later placed in
the Interrupt Vector Table so that, it will be called when interrupted.
</P>

<P>
The following code is a basic implementation of an ISR.
</P>

<PRE>
void interrupt yourisr()   /* Interrupt Service Routine (ISR) */
{
  disable();

  /* Body of ISR goes here */
	      
  oldhandler();

  outportb(0x20,0x20);     /* Send EOI to PIC1 */
  enable();
}
</PRE>

<P>
<font color="#400080"><TT>void interrupt yourisr()</TT></font>
defines this function as an Interrupt Service Routine. <font color="#400080">
<TT>disable();</TT></font> clears the interrupt flag, so that
no other hardware interrupts ,except a NMI (Non-Maskable Interrupt) can
occur. Otherwise, and interrupt with a higher priority that this one
can interrupt the execution of this ISR. However this is not really
a problem in many cases, thus is optional.
</P>

<p>
The body of your ISR will include code which you want to execute upon
this interrupt request being activated. Most Ports/UARTs may interrupt
the processor for a range of reasons, eg byte received, time-outs, FIFO
buffer empty, overruns etc, thus the nature of the interrupt has to be
determined. This is normally achieved by reading the status registers
of the port you are using. Once it has been established, you can service
it's requests.
</P>

<p>
If you read any data from a port, it is normally common practice to
place it in a buffer, rather that immediately writing it to the screen,
inhibiting further interrupts to be processed. Most Ports these days will
have FIFO buffers which can contain more than one byte, thus repeat your
read routine, until the FIFO is empty, then exit your ISR.
</P>

<p>
In some cases it may be appropriate to chain the old ISR to this one. Such
an example would be the Clock Interrupt. Other TSR or resident programs
may also be using it, thus if you intercept the interrupt and keep it
all for yourself, the other ISR's can no longer function possibly causing
some side effects. However for Serial/Parallel Ports this is not a problem. 
To chain the old ISR to your new ISR, you can call it using
<font color="#400080"><TT>oldhandler();</TT></font> where <TT>oldhandler</TT>
points to your old ISR.
</TT>

<p>
Before we can return from the interrupt, we must tell the Programmable
Interrupt Controller, that we are ending the interrupt by sending
an EOI (End of Interrupt 0x10) to it. As there are two PIC's you must
first establish which one to send it to. Use
<font color="#400080"><TT>outportb(0x20,0x20);</TT></font> for PIC 1 (IRQ 0 - 7) or 
<font color="#400080"><TT>outportb(0xA0,0x20);</TT></font> for PIC 2 (IRQ 8 - 15).
</P>

<P>
<I>Note: If using PIC2, then an EOI has to be sent to both PIC1 and PIC2.
</I>
</P>

<A NAME="5"></A>
<HR width="100%"><I><FONT SIZE=+2>Using your new Interrupt Service Routine</FONT></I>
<HR width="100%">

<p>
Now that we have written our new interrupt service routine, we can start
looking at how to implement it. The following code segment shows the
basic usage of your new ISR. For this example we have chosen to use
IRQ 3.
</P>

<PRE>
#include &lt;dos.h&gt;

#define INTNO 0x0B                     /* Interupt Number - See Table 1 */

void main(void)
{
 oldhandler = getvect(INTNO);           /* Save Old Interrupt Vector */
 setvect(INTNO, yourisr);               /* Set New Interrupt Vector Entry */
 outportb(0x21,(inportb(0x21) & 0xF7)); /* Un-Mask (Enable) IRQ3 */ 

 /* Set Card - Port to Generate Interrupts */

 /* Body of Program Goes Here */

 /* Reset Card - Port as to Stop Generating Interrupts */

 outportb(0x21,(inportb(0x21) | 0x08)); /* Mask (Disable) IRQ3 */ 
 setvect(INTNO, oldhandler);            /* Restore old Interrupt Vector Before Exit */
}
</PRE>

<P>
Before you can place the address of your new ISR in the interrupt vector
table, you must first save the old interrupt vector, so that you can restore
it once you exit your program. This is done using <font color="#400080">
<TT>oldhandler = getvect(INTNO);</TT></font> where INTNO is the number of
the interrupt vector you wish to return. Before <TT>oldhandler</TT> can be
used, you must first declare it using <font color="#400080"><TT>void
interrupt ( *oldhandler)();</TT></font>
</P>

<P>
Once the old interrupt vector is stored, we can now install your new ISR
into the interrupt vector table. This is done using the line
<font color="#400080"><TT> setvect(INTNO, yourisr);</TT></font> where
<TT>yourisr</TT> points to your interrupt service routine.
</P>

<p>
The IRQ which you are using must now be unmasked. We have already discussed
this earlier. See <A HREF="#3">Hardware Interrupts</A>.
</P>

<p>
Most Ports/UARTs will need some initialization to be able to generate
interrupts. For Example, The Standard Parallel Port (SPP) will require
Bit 4 of the Control Port, <I> Enable IRQ Via ACK Line</I> to be set at
Base + 2. The Serial Port will require the appropriate setting of
Bits 0 to 4 of the Interrupt Enable Register (IER) located at Base + 1.
</P>

<P>
Your body of the program normally consists of a few housekeeping tasks
depending upon your application. Here you look for new keys pressed, menus
being selected, updating clocks, checking for incoming data in buffers etc,
knowing that any data from your Ports will be automatically read and
processed, by the ISR.
</P>

<p>
If you like implementing ISR's so much, you can attach your own ISR to
the Keyboard Interrupt, so any keys being pressed will be automatically
handled by another ISR, and even one to the clock. Upon every 18.2 ticks
you can update the seconds on your display! The possibilities of ISR's are
endless.
</P>
    
<P>
Before you exit your program always restore the old interrupt vector, so
that your computer doesn't become unstable. This is done using <TT>
<font color="#400080">setvect(INTNO, oldhandler); </font></TT>, where
<TT>oldhandler</TT> points to the old interrupt service routine, which
we stored using <font color="#400080"><TT> oldhandler = getvect(INTNO);
</TT></font>
</P>

<A NAME="6"></A>
<HR width="100%"><I><FONT SIZE=+2>The Programmable Interrupt Controller</FONT></I>
<HR width="100%">

<P>
As we have all ready discussed, the Interrupt ReQuests (IRQ's) of a PC is 
handled by two 8259 Programmable
Interrupt Controllers. On the old XT's/AT's these were two 28 Pin DIP IC's, but as
you can imagine, things have changed dramatically since then. While the
operational principal is still the same, the PIC is now integrated somewhere
into your chipset, along with many other devices.
</P>
<center><img src="piclogic.gif" alt="Internal's of a Programmable Interrupt Controller" border=0 height=344 width=645></center>
<P>
The basic block diagram of the PIC is shown above. The 8 individual interrupt
request lines are first passed through the Interrupt Mask Register (IMR) to
see if they have been masked or not. If they are masked, then the request
isn't processed any further. However if they are not masked, they will
register their request with the Interrupt Request Register (IRR).
</P>
<P>
The Interrupt Request Register will hold all the requested IRQ's until they
have been dealt with appropriately. If required, this register can be read
by setting certain bits of the
<a href="#15">Operation Control Word 3</A>. The Priority
Resolver simply selects the IRQ of highest priority. The higher priority
interrupts are the lower numbered ones. For Example IRQ 0 has the highest
priority followed by IRQ 1 etc.
</P>
<p>
Now that the PIC has determined which IRQ to process, it is now time to
tell the processor, so that it can call your ISR for you. This process is
done by sending a INT to the processor, i.e. the INT line on the processor
is asserted. The processor will then finish the current instruction it's
processing and acknowledge your INT request with a INTA (Interrupt
Acknowledge) pulse.
</P>
<p>
Upon receiving the processor's INTA, the IRQ which the PIC is processing at the time is stored
in the In Service Register (ISR) which as the name suggests, shows which
IRQ is currently in service. The IRQ's bit is also reset in the Interrupt
Request Register, as it is no longer requesting service but actually getting
service.
</P>
<p>
Another INTA pulse will be sent by the processor, to tell the PIC to place
a 8 bit pointer on the data bus, corresponding to the IRQ number. If an IRQ
serviced by PIC2 is requesting the service, then PIC2 will send
the pointer to the processor. The Master (PIC1) at this stage, will select
PIC2 to send the pointer, by placing PIC2's Slave ID on the Cascade lines,
which is a 3 wire bus between all the PIC's in a system.
</P>
<P>
The 5 most
significant bits of this pointer is set using the Initialization Command
Word 2 (ICW2). This will be 00001 for PIC1 and 01110 for PIC2. The three
least significant bits, will be sent due to which IRQ is being serviced.
For example, if IRQ3 is requesting service then the 8 bit pointer will
be made up with 00001 for the 5 most significant bits and 011 (IR3) for the
least significant bits. Put this together and you get 00001011 or 0x0B which
just happens to be IRQ3's interrupt vector.
</P>
<P>
For PIC2, the same principal
is applied. If IRQ10 is requesting service, then 01110010 will be sent, which
just happens to represent Interrupt 72h. IRQ10 happens to be connected to
IR2 on the Second PIC, thus 010 is used as the least significant bits.
</P>
<P>
Once your ISR has done everything it needs, it sends an End of Interrupt
(EOI) to the PIC, which resets the In-Service Register. If the request
came from PIC2, then EOI's are required to be sent to both PICs.
The PIC will then determine the next highest priority interrupt and
repeat the same process. If no Interrupt Requests are present, then
the PIC waits for the next request before interrupting the processor.
</P>

<A NAME="7"></A>
<HR width="100%"><I><FONT SIZE=+2>IRQ2/IRQ9 Redirection</FONT></I>
<HR width="100%">

<P>
The redirection of IRQ2 causes quite some confusion, and thus is discussed
here. In the original XT's there were only one PIC, thus only eight IRQ's.
However users soon out grew these resources, thus an additional 7 IRQ's
were added to the PC. This involved attaching another PIC to the existing
one already in the XT. Compatibility always causes problems as the new
configuration still had to be compatible with old hardware and software. 
The "new" configuration is shown below.
</P>

<center><img src="irq2irq9.gif" alt="IRQ2/IRQ9 Redirection Schematic" border=0 height=455 width=402></center>

<p>
The CPU only has one interrupt line, thus the second controller had to be
connected to the first controller, in a master/slave configuration. IRQ2 was
selected for this. By using IRQ2 for the second controller, no other
devices could use IRQ2, so what happened to all these devices using IRQ2?
Nothing, the interrupt request line found on the bus, was simply diverted
into the IRQ 9 input. As no devices yet used the second PIC or IRQ9, this
could be done.
</P>
<p>
The next problem was that a hardware device using IRQ2 would install it's
ISR at INT 0x0A. Therefore an ISR routine was used at INT 71h, which sent
a EOI to PIC2 and then called the ISR at INT 0x0A. If you dis-assemble
the ISR for IRQ9, it will go a little like,
</P>
<center>
<Table width="80%">
<TR><TD>
<PRE>
MOV AL,20
OUT A0,AL   ; Send EOI to PIC2
INT 0A      ; Call ISR for IRQ2
IRET        
</PRE>
</TD></TR>
</TABLE>
</center>
<P>
The routine only has to send a EOI to PIC2, as it is expected that a ISR
routine written for IRQ2 will send a EOI to PIC1. This example destroys 
the contents of Register AL, thus this must be placed on the stack first (Not
shown in example). As PIC2
is initialized with a Slave on IRQ2, any request using PIC2 will
not call the ISR routine for IRQ2. The 8 bit pointer will come from PIC2.
</p>

<A NAME="8"></A>
<HR width="100%"><I><FONT SIZE=+2>Programmable Interrupt Controller's Addresses</FONT></I>
<HR width="100%">

<P>
The two PIC's found in an IBM compatible system are initialized via BIOS
thus you don't have to worry about all of their registers. However for
some people, who have inquisitive minds the following information may come
in some use or maybe you want to (re)program a BIOS?
Below is a table of all the command words of the 8259 and
compatible Programmable Interrupt Controller. The Top Table shows the
Addresses for the PIC1, while the bottom table shows addresses for PIC2.
</P>
<p>
<center>
<Table border width="80%">
<TR><TD><B><center>Address</center></B></TD><TD><B><center>Read/Write</center></B></TD><TD><B>Function</B></TD></TR>
<TR><TD rowspan=5><center>20h</center></td><TD><center>Write</center></TD><TD>Initialization Command Word 1 (ICW1)</TD></TR>
<TR>                                       <TD><center>Write</center></TD><TD>Operation Command Word 2 (OCW2)</TD></TR>
<TR>                                       <TD><center>Write</center></TD><TD>Operation Command Word 3 (OCW3)</TD></TR>
<TR>                                       <TD><center>Read</center></TD><TD>Interrupt Request Register (IRR)</TD></TR>
<TR>                                       <TD><center>Read</center></TD><TD>In-Service Register (ISR)</TD></TR>
<TR><TD rowspan=4><center>21h</center></td><TD><center>Write</center></TD><TD>Initialization Command Word 2 (ICW2)</TD></TR>
<TR>                                       <TD><center>Write</center></TD><TD>Initialization Command Word 3 (ICW3)</TD></TR>
<TR>                                       <TD><center>Write</center></TD><TD>Initialization Command Word 4 (ICW4)</TD></TR>
<TR>                                       <TD><center>Read/Write</center></TD><TD>Interrupt Mask Register (IMR)</TD></TR>
</table>
<font size=-1>Table 4 : Addresses/Registers for PIC1 </FONT>
</center>
</P>

<P>
PIC2 Addresses . . .
</P>

<P>
<center>
<Table border width="80%">
<TR><TD><B><center>Address</center></B></TD><TD><B><center>Read/Write</center></B></TD><TD><B>Function</B></TD></TR>
<TR><TD rowspan=5><center>A0h</center></td><TD><center>Write</center></TD><TD>Initialization Command Word 1 (ICW1)</TD></TR>
<TR>                                       <TD><center>Write</center></TD><TD>Operation Command Word 2 (OCW2)</TD></TR>
<TR>                                       <TD><center>Write</center></TD><TD>Operation Command Word 3 (OCW3)</TD></TR>
<TR>                                       <TD><center>Read</center></TD><TD>Interrupt Request Register (IRR)</TD></TR>
<TR>                                       <TD><center>Read</center></TD><TD>In-Service Register (ISR)</TD></TR>
<TR><TD rowspan=4><center>A1h</center></td><TD><center>Write</center></TD><TD>Initialization Command Word 2 (ICW2)</TD></TR>
<TR>                                       <TD><center>Write</center></TD><TD>Initialization Command Word 3 (ICW3)</TD></TR>
<TR>                                       <TD><center>Write</center></TD><TD>Initialization Command Word 4 (ICW4)</TD></TR>
<TR>                                       <TD><center>Read/Write</center></TD><TD>Interrupt Mask Register (IMR)</TD></TR>
</table>
<font size=-1>Table 5 : Addresses/Registers for PIC2 </FONT>
</center>
</P>

<A NAME="9"></A>
<HR width="100%"><I><FONT SIZE=+2>Initialization Command Word 1 (ICW1)</FONT></I>
<HR width="100%">

<p>
If the PIC has been reset, it must be initialized with 2 to 4 Initialization 
Command Words (ICW) before it will accept and process Interrupt Requests. The 
following selection outlines the four possible Initialization Command Words.
</P>

<P>
<center>
<table border width="70%">
<TR><TD><B><center>Bit(s)</center><B></TD><TD colspan=2><B>Function</B></TD></TR>
<TR><TD><center>7:5</center></TD><TD colspan=2>Interrupt Vector Addresses for MCS-80/85 Mode.</TD></TR>
<TR><TD><center>4</center></TD><TD colspan=2>Must be set to 1 for ICW1</TD></TR>
<TR><TD rowspan=2><center>3</center></TD><TD><center>1</center></TD><TD>Level Triggered Interrupts</TD></TR>
<TR>                                     <TD><center>0</center></TD><TD>Edge Triggered Interrupts</TD></TR>
<TR><TD rowspan=2><center>2</center></TD><TD><center>1</center></TD><TD>Call Address Interval of 4</TD></TR>
<TR>                                     <TD><center>0</center></TD><TD>Call Address Interval of 8</TD></TR>
<TR><TD rowspan=2><center>1</center></TD><TD><center>1</center></TD><TD>Single PIC</TD></TR>
<TR>                                     <TD><center>0</center></TD><TD>Cascaded PICs</TD></TR>
<TR><TD rowspan=2><center>0</center></TD><TD><center>1</center></TD><TD>Will be Sending ICW4</TD></TR>
<TR>                                     <TD><center>0</center></TD><TD>Don't need ICW4</TD></TR>
</table>
<font size=-1>Table 6 : Initialization Command Word 1 (ICW1) </FONT>
</center>
</P>

<P>
The 8259 Programmable Interrupt Controller, offers many other features which
are not used in the PC. It also offers support for MCS-80/85 microprocessors.
All we have to be aware of being PC uses, is if the system is running in single mode (One PIC) 
or if in Cascaded Mode (More than one PIC) and if the Initialization Command Word 
4 is needed. If no ICW4 is used, then all of it's bits will be set to 0. As
we are using it in 8086 mode, we must send a ICW4.
</P>

<A NAME="10"></A>
<HR width="100%"><I><FONT SIZE=+2>Initialization Command Word 2 (ICW2)</FONT></I>
<HR width="100%">

<P>
<center>
<Table border width="80%">
<TR><TD><Center><B>Bit</B></Center></TD><TD><Center><B>8086/8080 Mode</B></Center></TD><TD><center><B>MCS 80/85 Mode</B></center></TD></TR>
<TR><TD><CENTER>7</CENTER></TD><TD><Center>I7</center></TD><TD><Center>A15</Center></TD></TR>
<TR><TD><CENTER>6</CENTER></TD><TD><Center>I6</center></TD><TD><Center>A14</Center></TD></TR>
<TR><TD><CENTER>5</CENTER></TD><TD><Center>I5</center></TD><TD><Center>A13</Center></TD></TR>
<TR><TD><CENTER>4</CENTER></TD><TD><Center>I4</center></TD><TD><Center>A12</Center></TD></TR>
<TR><TD><CENTER>3</CENTER></TD><TD><Center>I3</center></TD><TD><Center>A11</Center></TD></TR>
<TR><TD><CENTER>2</CENTER></TD><TD><Center> - </center></TD><TD><Center>A10</Center></TD></TR>
<TR><TD><CENTER>1</CENTER></TD><TD><Center> - </center></TD><TD><Center>A9</Center></TD></TR>
<TR><TD><CENTER>0</CENTER></TD><TD><Center> - </center></TD><TD><Center>A8</Center></TD></TR>
</table>
<font size=-1>Table 7 : Initialization Command Word 2 (ICW2) </FONT>
</center>
</P>

<P>
Initialization Command Word 2 (ICW2) selects which vector information is
released onto the bus, during the 2nd INTA Pulse. Using the 8086 mode, 
only bits 7:3 need to be used. This will be 00001000 (0x08) for PIC1 and 
01110000 (0x70) for PIC2. If you wish to relocate the IRQ Vector Table,
then you can use this register.
</P>

<A NAME="11"></A>
<HR width="100%"><I><FONT SIZE=+2>Initialization Command Word 3 (ICW3)</FONT></I>
<HR width="100%">

<p>
There are two different Initialization Command Word 3's. One is used, if 
the PIC is a master, while the other is used for slaves. The top table
shows the ICW3 for the master.
</P>

<P>
<center>
<Table border width="80%">
<TR><TD><Center><B>Bit</B></Center></TD><TD><center><B>Function</B></center></TD></TR>
<TR><TD><CENTER>7</CENTER></TD><TD>IR7 is connected to a Slave</center></TD></TR>
<TR><TD><CENTER>6</CENTER></TD><TD>IR6 is connected to a Slave</center></TD></TR>
<TR><TD><CENTER>5</CENTER></TD><TD>IR5 is connected to a Slave</center></TD></TR>
<TR><TD><CENTER>4</CENTER></TD><TD>IR4 is connected to a Slave</center></TD></TR>
<TR><TD><CENTER>3</CENTER></TD><TD>IR3 is connected to a Slave</center></TD></TR>
<TR><TD><CENTER>2</CENTER></TD><TD>IR2 is connected to a Slave</center></TD></TR>
<TR><TD><CENTER>1</CENTER></TD><TD>IR1 is connected to a Slave</center></TD></TR>
<TR><TD><CENTER>0</CENTER></TD><TD>IR0 is connected to a Slave</center></TD></TR>
</table>
<font size=-1>Table 8 : Initialization Command Word 3 for Master PIC (ICW3)  </FONT>
</center>
</P>

<P>
And for the slave device, the ICW3 below is used.
</P>

<center>
<table border width="80%">
<TR><TD width="15%"><B><center>Bit(s)</center><B></TD><TD colspan=2><B>Function</B></TD></TR>

<TR><TD><center>7</center></TD><TD colspan=2>Reserved. Set to 0</TD></TR>
<TR><TD><center>6</center></TD><TD colspan=2>Reserved. Set to 0</TD></TR>
<TR><TD><center>5</center></TD><TD colspan=2>Reserved. Set to 0</TD></TR>
<TR><TD><center>4</center></TD><TD colspan=2>Reserved. Set to 0</TD></TR>
<TR><TD><center>3</center></TD><TD colspan=2>Reserved. Set to 0</TD></TR>
<TR><TD rowspan=9 valign=top><center>2:0</center></TD><TD colspan=2><I>Slave ID</I></TD></TR>
<TR>                                                  <TD width="10%"><center>000</center></TD><TD>Slave 0</TD></TR>
<TR>                                                  <TD><center>001</center></TD><TD>Slave 1</TD></TR>
<TR>                                                  <TD><center>010</center></TD><TD>Slave 2</TD></TR>
<TR>                                                  <TD><center>011</center></TD><TD>Slave 3</TD></TR>
<TR>                                                  <TD><center>100</center></TD><TD>Slave 4</TD></TR>
<TR>                                                  <TD><center>101</center></TD><TD>Slave 5</TD></TR>
<TR>                                                  <TD><center>110</center></TD><TD>Slave 6</TD></TR>
<TR>                                                  <TD><center>111</center></TD><TD>Slave 7</TD></TR>
</table>
<font size=-1>Table 9 : Initialization Command Word 3 for Slaves (ICW3)  </FONT>
</center>
<P>
</P>

<A NAME="12"></A>
<HR width="100%"><I><FONT SIZE=+2>Initialization Command Word 4 (ICW4)</FONT></I>
<HR width="100%">

<P>
<center>
<table border width="80%">
<TR><TD><B><center>Bit(s)</center><B></TD><TD colspan=2><B>Function</B></TD></TR>
<TR><TD><center>7</center></TD><TD colspan=2>Reserved. Set to 0</TD></TR>
<TR><TD><center>6</center></TD><TD colspan=2>Reserved. Set to 0</TD></TR>
<TR><TD><center>5</center></TD><TD colspan=2>Reserved. Set to 0</TD></TR>
<TR><TD rowspan=2><center>4</center></TD><TD><center>1</center></TD><TD>Special Fully Nested Mode</TD></TR>
<TR>                                     <TD><center>0</center></TD><TD>Not Special Fully Nested Mode </TD></TR>
<TR><TD rowspan=3 valign=top><center>3:2</center></TD><TD><center>0x</center></TD><TD>Non - Buffered Mode</TD></TR>
<TR>                                       <TD><center>10</center></TD><TD>Buffered Mode - Slave </TD></TR>
<TR>                                       <TD><center>11</center></TD><TD>Buffered Mode - Master</TD></TR>
<TR><TD rowspan=2><center>1</center></TD><TD><center>1</center></TD><TD>Auto EOI</TD></TR>
<TR>                                     <TD><center>0</center></TD><TD>Normal EOI</TD></TR>
<TR><TD rowspan=2><center>0</center></TD><TD><center>1</center></TD><TD>8086/8080 Mode</TD></TR>
<TR>                                     <TD><center>0</center></TD><TD>MCS-80/85 </TD></TR>
</table>
<font size=-1>Table 10 : Initialization Command Word 4 (ICW4)</FONT>
</center>
</P>

<P>
Once again, many of these are special functions not used with the 8259 PIC in a 
PC. We don't use, Special Fully Nested Mode, thus this bit is set to 0. 
Likewise we use non-buffered mode and Normal EOI's thus all these corresponding
bits are set to 0. The only thing we must set is 8086/8080 Mode which is 
done using Bit 0.
</P>

<A NAME="13"></A>
<HR width="100%"><I><FONT SIZE=+2>Operation Control Word 1 (OCW1)</FONT></I>
<HR width="100%">
<P>
Once all the required Initialization Command Words have been sent to the PIC,
then you can send Operation Control Words, in any order and at any time
during the PIC's operation. The Operation Control Words are shown in the 
next sections.
</P>

<P>
<center>
<Table border width="80%">
<TR><TD><Center><B>Bit</B></Center></TD><TD><Center><B>PIC 2</B></Center></TD><TD><center><B>PIC 1</B></center></TD></TR>
<TR><TD><CENTER>7</CENTER></TD><TD><Center>Mask IRQ15</center></TD><TD><Center>Mask IRQ7</Center></TD></TR>
<TR><TD><CENTER>6</CENTER></TD><TD><Center>Mask IRQ14</center></TD><TD><Center>Mask IRQ6</Center></TD></TR>
<TR><TD><CENTER>5</CENTER></TD><TD><Center>Mask IRQ13</center></TD><TD><Center>Mask IRQ5</Center></TD></TR>
<TR><TD><CENTER>4</CENTER></TD><TD><Center>Mask IRQ12</center></TD><TD><Center>Mask IRQ4</Center></TD></TR>
<TR><TD><CENTER>3</CENTER></TD><TD><Center>Mask IRQ11</center></TD><TD><Center>Mask IRQ3</Center></TD></TR>
<TR><TD><CENTER>2</CENTER></TD><TD><Center>Mask IRQ10</center></TD><TD><Center>Mask IRQ2</Center></TD></TR>
<TR><TD><CENTER>1</CENTER></TD><TD><Center>Mask IRQ9</center></TD><TD><Center>Mask IRQ1</Center></TD></TR>
<TR><TD><CENTER>0</CENTER></TD><TD><Center>Mask IRQ8</center></TD><TD><Center>Mask IRQ0</Center></TD></TR>
</table>
<font size=-1>Table 11 : Operation Control Word 1 (OCW1) </FONT>
</center>
</P>
<P>
Operation Control Word 1, shown above is used to mask the inputs of the 
PIC. This has already been discussed, earlier in this article.
</P>
<A NAME="14"></A>
<HR width="100%"><I><FONT SIZE=+2>Operation Control Word 2 (OCW2)</FONT></I>
<HR width="100%">

<P>
<center>
<table border width="80%">
<TR><TD><B><center>Bit(s)</center><B></TD><TD colspan=2><B>Function</B></TD></TR>
<TR><TD rowspan=8 valign=top><center>7:5</center></TD><TD><center>000</center></TD><TD>Rotate in Auto EOI Mode (Clear)</TD></TR>
<TR>                                                  <TD><center>001</center></TD><TD>Non Specific EOI</TD></TR>
<TR>                                                  <TD><center>010</center></TD><TD>Reserved </TD></TR>
<TR>                                                  <TD><center>011</center></TD><TD>Specific EOI</TD></TR>
<TR>                                                  <TD><center>100</center></TD><TD>Rotate in Auto EOI Mode (Set)</TD></TR>
<TR>                                                  <TD><center>101</center></TD><TD>Rotate on Non-Specific EOI</TD></TR>
<TR>                                                  <TD><center>110</center></TD><TD>Set Priority Command (Use Bits 2:0) </TD></TR>
<TR>                                                  <TD><center>111</center></TD><TD>Rotate on Specific EOI (Use Bits 2:0)</TD></TR>
<TR><TD><center>4</center></TD><TD colspan=2>Must be set to 0</TD></TR>
<TR><TD><center>3</center></TD><TD colspan=2>Must be set to 0</TD></TR>
<TR><TD rowspan=8 valign=top><center>2:0</center></TD><TD><center>000</center></TD><TD>Act on IRQ 0 or 8</TD></TR>
<TR>                                                  <TD><center>001</center></TD><TD>Act on IRQ 1 or 9</TD></TR>
<TR>                                                  <TD><center>010</center></TD><TD>Act on IRQ 2 or 10</TD></TR>
<TR>                                                  <TD><center>011</center></TD><TD>Act on IRQ 3 or 11</TD></TR>
<TR>                                                  <TD><center>100</center></TD><TD>Act on IRQ 4 or 12</TD></TR>
<TR>                                                  <TD><center>101</center></TD><TD>Act on IRQ 5 or 13</TD></TR>
<TR>                                                  <TD><center>110</center></TD><TD>Act on IRQ 6 or 14</TD></TR>
<TR>                                                  <TD><center>111</center></TD><TD>Act on IRQ 7 or 15</TD></TR>
</table>
<font size=-1>Table 12 : Operation Control Word 2 (OCW2) </FONT>
</center>
</P>
<P>
Operation Control Word 2 selects how the End of Interrupt (EOI) procedure works. The
only thing of interest to us in this register is the non-specific EOI 
command, which we must send at the end of our ISR's.
</P>

<A NAME="15"></A>
<HR width="100%"><I><FONT SIZE=+2>Operation Control Word 3 (OCW3)</FONT></I>
<HR width="100%">

<p>
<center>
<table width="80%" border>
<TR><TD><B><center>Bit(s)</center><B></TD><TD colspan=2><B>Function</B></TD></TR>

<TR><TD><center>7</center></TD><TD colspan=2>Must be set to 0</TD></TR>
<TR><TD rowspan=4 valign=top><center>6:5</center></TD><TD><center>00</center></TD><TD>Reserved</TD></TR>
<TR>                                       <TD><center>01</center></TD><TD>Reserved</TD></TR>
<TR>                                       <TD><center>10</center></TD><TD>Reset Special Mask </TD></TR>
<TR>                                       <TD><center>11</center></TD><TD>Set Special Mask</TD></TR>
<TR><TD><center>4</center></TD><TD colspan=2>Must be set to 0</TD></TR>
<TR><TD><center>3</center></TD><TD colspan=2>Must be set to 1</TD></TR>
<TR><TD rowspan=2><center>2</center></TD><TD><center>1</center></TD><TD>Poll Command</TD></TR>
<TR>                                     <TD><center>0</center></TD><TD>No Poll Command</TD></TR>
<TR><TD rowspan=4 valign=top><center>1:0</center></TD><TD><center>00</center></TD><TD>Reserved</TD></TR>
<TR>                                       <TD><center>01</center></TD><TD>Reserved</TD></TR>
<TR>                                       <TD><center>10</center></TD><TD>Next Read Returns Interrupt Request Register </TD></TR>
<TR>                                       <TD><center>11</center></TD><TD>Next Read Returns In-Service Register</TD></TR>
</table>
<font size=-1>Table 13 : Operation Control Word 3 (OCW3) </FONT>
</center>
</P>
<P>
Bits 0 and 1 are of the most significant to us, in Operation Control Word 3.
These two bits enable us to read the status of the Interrupt Request Register
(IRR) and the In-Service Register (ISR). This is done by setting the 
appropriate bits correctly as above, and reading the register at the Base 
Address.
</P>
<P>
For example if we wanted to read the In-Service Register (ISR), then we would 
set both bits 1 and 0 to 1. The next read to the base register, (0x20 for
PIC1 or 0xA0 for PIC2) will return the status of the In-Service Register.
</P>

</UL>
<HR>
<CENTER>
<TABLE WIDTH="90%" BORDER=0>
<TR>
<TD BGCOLOR=BLUE HEIGHT=25 WIDTH="20%"><FONT FACE=ARIAL COLOR=WHITE><B><CENTER><A ID="TITLEBLOCK" HREF="/index.html#PARALLEL">Parallel Ports</a></CENTER></B></FONT></TD>
<TD BGCOLOR=BLUE HEIGHT=25 WIDTH="20%"><FONT FACE=ARIAL COLOR=WHITE><B><CENTER><A ID="TITLEBLOCK" HREF="/index.html#SERIAL">Serial / RS-232 Ports</a></CENTER></B></FONT></TD>
<TD BGCOLOR=BLUE HEIGHT=25 WIDTH="20%"><FONT FACE=ARIAL COLOR=WHITE><B><CENTER><A ID="TITLEBLOCK" HREF="/index.html#INTERRUPTS">Interrupts</a></CENTER></B></FONT></TD>
<TD BGCOLOR=BLUE HEIGHT=25 WIDTH="20%"><FONT FACE=ARIAL COLOR=WHITE><B><CENTER><A ID="TITLEBLOCK" HREF="/index.html#ATKEYBOARDS">AT Keyboard Ports</a></CENTER></B></FONT></TD>
<TD BGCOLOR=BLUE HEIGHT=25 WIDTH="20%"><FONT FACE=ARIAL COLOR=WHITE><B><CENTER><A ID="TITLEBLOCK" HREF="/index.html#USB">USB</a></CENTER></B></FONT></TD>
</TR>
</TABLE>
<HR>
<FONT SIZE=2>
Copyright 1997-2000 <A href="mailto:cpeacock@senet.com.au(Craig Peacock)">Craig Peacock </a> - Monday 28th February 2000.
<HR>
</CENTER>
</FONT>
</BODY>
</HTML>
