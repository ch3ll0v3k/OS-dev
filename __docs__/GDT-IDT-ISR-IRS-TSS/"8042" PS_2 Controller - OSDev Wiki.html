<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>"8042" PS/2 Controller - OSDev Wiki</title>
<meta charset="UTF-8" />
<meta name="generator" content="MediaWiki 1.18.0" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="OSDev Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.osdev.org/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}

/* cache key: wikidb:resourceloader:filter:minify-css:4:c88e2bcd56513749bec09a7e29cb3ffa */
</style>
<script src="/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "\"8042\"_PS/2_Controller", "wgTitle": "\"8042\" PS/2 Controller", "wgCurRevisionId": 17935, "wgArticleId": 3160, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": ["X86", "Common Devices"], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script>
<style type="text/css">/*<![CDATA[*/
.source-asm {line-height: normal;}
.source-asm li, .source-asm pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for asm
 * CSS class: source-asm, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.asm.source-asm .de1, .asm.source-asm .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.asm.source-asm  {font-family:monospace;}
.asm.source-asm .imp {font-weight: bold; color: red;}
.asm.source-asm li, .asm.source-asm .li1 {font-weight: normal; vertical-align:top;}
.asm.source-asm .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.asm.source-asm .li2 {font-weight: bold; vertical-align:top;}
.asm.source-asm .kw1 {color: #00007f; font-weight: bold;}
.asm.source-asm .kw2 {color: #0000ff; font-weight: bold;}
.asm.source-asm .kw3 {color: #00007f;}
.asm.source-asm .kw4 {color: #000000; font-weight: bold;}
.asm.source-asm .kw5 {color: #000000; font-weight: bold;}
.asm.source-asm .co1 {color: #666666; font-style: italic;}
.asm.source-asm .co2 {color: #adadad; font-style: italic;}
.asm.source-asm .es0 {color: #000099; font-weight: bold;}
.asm.source-asm .br0 {color: #009900; font-weight: bold;}
.asm.source-asm .sy0 {color: #339933;}
.asm.source-asm .st0 {color: #7f007f;}
.asm.source-asm .nu0 {color: #0000ff;}
.asm.source-asm .ln-xtra, .asm.source-asm li.ln-xtra, .asm.source-asm div.ln-xtra {background-color: #ffc;}
.asm.source-asm span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-_8042_PS_2_Controller action-view skin-vector">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading">"8042" PS/2 Controller</h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
								<!-- tagline -->
				<div id="siteSub">From OSDev Wiki</div>
				<!-- /tagline -->
								<!-- subtitle -->
				<div id="contentSub"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav">
					Jump to: <a href="#mw-head">navigation</a>,
					<a href="#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodycontent -->
				<div lang="en" dir="ltr" class="mw-content-ltr"><table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#History"><span class="tocnumber">2</span> <span class="toctext">History</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Translation"><span class="tocnumber">2.1</span> <span class="toctext">Translation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#USB_Legacy_Support"><span class="tocnumber">3</span> <span class="toctext">USB Legacy Support</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Buffer_Naming_Perspective"><span class="tocnumber">4</span> <span class="toctext">Buffer Naming Perspective</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#PS.2F2_Controller_IO_Ports"><span class="tocnumber">5</span> <span class="toctext">PS/2 Controller IO Ports</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="#Data_Port"><span class="tocnumber">5.1</span> <span class="toctext">Data Port</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Status_Register"><span class="tocnumber">5.2</span> <span class="toctext">Status Register</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Command_Register"><span class="tocnumber">5.3</span> <span class="toctext">Command Register</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#PS.2F2_Controller_Commands"><span class="tocnumber">6</span> <span class="toctext">PS/2 Controller Commands</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#PS.2F2_Controller_Configuration_Byte"><span class="tocnumber">6.1</span> <span class="toctext">PS/2 Controller Configuration Byte</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#PS.2F2_Controller_Output_Port"><span class="tocnumber">6.2</span> <span class="toctext">PS/2 Controller Output Port</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13"><a href="#Initialising_the_PS.2F2_Controller"><span class="tocnumber">7</span> <span class="toctext">Initialising the PS/2 Controller</span></a>
<ul>
<li class="toclevel-2 tocsection-14"><a href="#Step_1:_Initialise_USB_Controllers"><span class="tocnumber">7.1</span> <span class="toctext">Step 1: Initialise USB Controllers</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Step_2:_Determine_if_the_PS.2F2_Controller_Exists"><span class="tocnumber">7.2</span> <span class="toctext">Step 2: Determine if the PS/2 Controller Exists</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Step_3:_Disable_Devices"><span class="tocnumber">7.3</span> <span class="toctext">Step 3: Disable Devices</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Step_4:_Flush_The_Output_Buffer"><span class="tocnumber">7.4</span> <span class="toctext">Step 4: Flush The Output Buffer</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Step_5:_Set_the_Controller_Configuration_Byte"><span class="tocnumber">7.5</span> <span class="toctext">Step 5: Set the Controller Configuration Byte</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Step_6:_Perform_Controller_Self_Test"><span class="tocnumber">7.6</span> <span class="toctext">Step 6: Perform Controller Self Test</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Step_7:_Determine_If_There_Are_2_Channels"><span class="tocnumber">7.7</span> <span class="toctext">Step 7: Determine If There Are 2 Channels</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Step_8:_Perform_Interface_Tests"><span class="tocnumber">7.8</span> <span class="toctext">Step 8: Perform Interface Tests</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#Step_9:_Enable_Devices"><span class="tocnumber">7.9</span> <span class="toctext">Step 9: Enable Devices</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Step_10:_Reset_Devices"><span class="tocnumber">7.10</span> <span class="toctext">Step 10: Reset Devices</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-24"><a href="#Detecting_PS.2F2_Device_Types"><span class="tocnumber">8</span> <span class="toctext">Detecting PS/2 Device Types</span></a></li>
<li class="toclevel-1 tocsection-25"><a href="#Hot_Plug_PS.2F2_Devices"><span class="tocnumber">9</span> <span class="toctext">Hot Plug PS/2 Devices</span></a></li>
<li class="toclevel-1 tocsection-26"><a href="#Sending_Bytes_To_Device.2Fs"><span class="tocnumber">10</span> <span class="toctext">Sending Bytes To Device/s</span></a>
<ul>
<li class="toclevel-2 tocsection-27"><a href="#First_PS.2F2_Port"><span class="tocnumber">10.1</span> <span class="toctext">First PS/2 Port</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="#Second_PS.2F2_Port"><span class="tocnumber">10.2</span> <span class="toctext">Second PS/2 Port</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-29"><a href="#Recieving_Bytes_From_Device.2Fs"><span class="tocnumber">11</span> <span class="toctext">Recieving Bytes From Device/s</span></a>
<ul>
<li class="toclevel-2 tocsection-30"><a href="#Polling"><span class="tocnumber">11.1</span> <span class="toctext">Polling</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#Interrupts"><span class="tocnumber">11.2</span> <span class="toctext">Interrupts</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-32"><a href="#CPU_Reset"><span class="tocnumber">12</span> <span class="toctext">CPU Reset</span></a></li>
<li class="toclevel-1 tocsection-33"><a href="#See_Also"><span class="tocnumber">13</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-34"><a href="#Threads"><span class="tocnumber">13.1</span> <span class="toctext">Threads</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#External_Links"><span class="tocnumber">13.2</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h2> <span class="mw-headline" id="Overview"> Overview </span></h2>
<p>The PS/2 Controller (often called a "Keyboard controller") is located on the mainboard. In the early days the controller was a single chip (8042). As of today it is part of the <a href="/Advanced_Integrated_Peripheral" title="Advanced Integrated Peripheral">Advanced Integrated Peripheral</a>.
</p><p>The name is misleading because the controller does more than controlling communication with PS/2 devices.
</p>
<table>
<tr>
<td><div class="thumb tright"><div class="thumbinner" style="width:444px;"><a href="/File:Ps2-kbc.png" class="image"><img alt="" src="/images/5/55/Ps2-kbc.png" width="442" height="291" class="thumbimage" /></a>  <div class="thumbcaption">Overview of the PS/2-Controller</div></div></div>
</td></tr></table>
<p><br />
</p>
<h2> <span class="mw-headline" id="History"> History </span></h2>
<p>The original uni-directional, single channel IBM PC and PC-XT keyboard interface was controlled by a multi purpose PPI (Intel 8048, Programmable peripheral interface; also used to control other functions, like sound and parity error).
The XT controller is 100% obsolete and won't be discussed further in this page.
</p><p><br />
With the PC-AT, IBM introduced new keyboards (with a new bi-directional protocol) and a new keyboard controller (Intel 8042). The old PPI was not part of the mother board any more. 
</p>
<table>
<tr>
<td><div class="thumb tright"><div class="thumbinner" style="width:444px;"><a href="/File:At-kbc.png" class="image"><img alt="" src="/images/3/39/At-kbc.png" width="442" height="215" class="thumbimage" /></a>  <div class="thumbcaption">Overview of the AT-Controller</div></div></div>
</td></tr></table>
<p>The 8042 was a powerful microcontroller. To reduce costs, some of the general purpose input/output capabilities of the AT controller was used to control various functions unrelated to the keyboard, including&#160;:
</p>
<ul><li> System Reset
</li><li> The <a href="/A20_Line" title="A20 Line">A20-Gate</a>
</li></ul>
<p><br />
With the introduction of the PS/2 series, the main change to the keyboard controller subsystem was its expansion to control both a keyboard and a mouse. Previously PC and compatible mice were connected to different physical interfaces, including <a href="/Serial_Ports" title="Serial Ports">Serial Ports</a>. The AT keyboard controller and its "clones" were not capable of interfacing the new PS/2 mouse. Eventually (around the late 80486 and early Pentium time frame) PS/2 style mice became popular, and "PC-compatible" controllers have supported dual channels from then on (nominally one keyboard and one mouse).
</p><p>For the keyboard functions proper, the PS2 and AT controllers are very similar. The adjunction of a second channel (for the mouse) has forced however to redefine a few status and control bits.
</p>
<h3> <span class="mw-headline" id="Translation"> Translation </span></h3>
<p>The original IBM-PC keyboards (using the old XT interface) used "scan code set 1". The new AT keyboards generated different scan codes, or "scan code set 2". This change would have created compatibility problems for software that was expecting different scan codes from the keyboard. To avoid the compatibility problem, the keyboard controller supports a translation mode. If translation is enabled the controller will translate "scan code set 2" into "scan code set 1".
</p><p>Whenever this translation is enabled (and by default, it is) there is no way to reverse it in software. For example, if you receive the byte 0xB5 from the controller, then you can't know if the original data (sent to the controller by the device) was the byte 0xB5; or if it was the two bytes 0xF0, 0x33; or if it was the two bytes 0xF0, 0xB3.
</p><p>For software to actually use "scan code set 2" (or the even newer, rarely used, "scan code set 3"), or to allow different types of devices to be used in the keyboard port, you need to disable this translation to avoid having the data from the device mangled.
</p>
<h2> <span class="mw-headline" id="USB_Legacy_Support"> USB Legacy Support </span></h2>
<p>By modern standards you will find many PCs bundled with <a href="/Universal_Serial_Bus" title="Universal Serial Bus">USB</a> input devices. Some PCs may not even have PS/2 connectors at all. To remain compatible with old software, the mainboard emulates USB Keyboards and Mice as PS/2 devices. This is called USB Legacy Support.
</p><p>Because the implementation differ by manufacturer and mainboard there are flaws and sometimes even bugs:
</p>
<ul><li> Some emulation layers also handle the communication with the real PS/2 connectors regardless of any connected USB device. So maybe not all capabilities of the PS/2 connectors and devices can be used. For example extended mouse modes needed to use the scroll wheel won't work or the keyboard only works on the first PS/2 connector and the mouse only on the second connector.
</li><li> The <a href="/index.php?title=SMM_BIOS&amp;action=edit&amp;redlink=1" class="new" title="SMM BIOS (page does not exist)">SMM BIOS</a> that's providing the PS/2 USB Legacy Support may not support extended memory techniques or <a href="/Long_Mode" title="Long Mode" class="mw-redirect">Long Mode</a> and may cause system crashes.
</li></ul>
<p>This USB Legacy Support should be disabled by the OS as soon as the OS initialises the USB Controller, and this should be done before the OS attempts to initialise the real PS/2 controller. Otherwise the OS would only be initialising the emulated PS/2 controller and there's a large risk of problems caused by deficiencies in the firmware's emulation.
</p>
<h2> <span class="mw-headline" id="Buffer_Naming_Perspective"> Buffer Naming Perspective </span></h2>
<p>The PS/2 controller has two (one byte) buffers for data - one buffer for data received from devices that is waiting to be read by your OS, and one for data written by your OS that is waiting to be sent to a PS/2 device. Most datasheets for PS/2 controllers are written from the perspective of the PS/2 device and not from the perspective of software running on the host. Because of this, the names given to these buffers are the opposite of what you expect: the output buffer contains a device's output data (data waiting to be read by software), and the input buffer contains a device's input (data that was sent by software).
</p><p><br />
</p>
<h2> <span class="mw-headline" id="PS.2F2_Controller_IO_Ports"> PS/2 Controller IO Ports </span></h2>
<p>The PS/2 Controller itself uses 2 IO ports (IO ports 0x60 and 0x64). Like many IO ports, reads and writes may access completely different internal registers.
</p><p>Historical note&#160;: The PC-XT PPI had used port 0x61 to reset the keyboard interrupt request signal  (among other unrelated functions). Port 0x61 has no keyboard related functions on AT and PS/2 compatibles.
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1}}}">

<tr>
<th> IO Port
</th>
<th> Access Type
</th>
<th> Purpose
</th></tr>
<tr>
<td> 0x60
</td>
<td> Read/Write
</td>
<td> Data Port
</td></tr>
<tr>
<td> 0x64
</td>
<td> Read
</td>
<td> Status Register
</td></tr>
<tr>
<td> 0x64
</td>
<td> Write
</td>
<td> Command Register
</td></tr></table>
<p><br />
</p>
<h3> <span class="mw-headline" id="Data_Port"> Data Port </span></h3>
<p>The Data Port (IO Port 0x60) is used for reading data that was received from a PS/2 device or from the PS/2 controller itself, and writing data to a PS/2 device or to the PS/2 controller itself.
</p><p><br />
</p>
<h3> <span class="mw-headline" id="Status_Register"> Status Register </span></h3>
<p>The Status Register contains various flags that indicate the state of the PS/2 controller. The meanings for each bit are:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1}}}">

<tr>
<th> Bit
</th>
<th> Meaning
</th></tr>
<tr>
<td> 0
</td>
<td> Output buffer status (0 = empty, 1 = full)
<p>(must be set before attempting to read data from IO port 0x60)
</p>
</td></tr>
<tr>
<td> 1
</td>
<td> Input buffer status (0 = empty, 1 = full)
<p>(must be clear before attempting to write data to IO port 0x60 or IO port 0x64)
</p>
</td></tr>
<tr>
<td> 2
</td>
<td> System Flag
<p>Meant to be cleared on reset and set by firmware (via. PS/2 Controller Configuration Byte) if the system passes self tests (POST)
</p>
</td></tr>
<tr>
<td> 3
</td>
<td> Command/data (0 = data written to input buffer is data for PS/2 device, 1 = data written to input buffer is data for PS/2 controller command)
</td></tr>
<tr>
<td> 4
</td>
<td> Unknown (chipset specific)
<p>May be "keyboard lock" (more likely unused on modern systems)
</p>
</td></tr>
<tr>
<td> 5
</td>
<td> Unknown (chipset specific)
<p>May be "receive time-out" or "second PS/2 port output buffer full"
</p>
</td></tr>
<tr>
<td> 6
</td>
<td> Time-out error (0 = no error, 1 = time-out error)
</td></tr>
<tr>
<td> 7
</td>
<td> Parity error (0 = no error, 1 = parity error)
</td></tr>
</table>
<p><br />
</p>
<h3> <span class="mw-headline" id="Command_Register"> Command Register </span></h3>
<p>The Command Port (IO Port 0x64) is used for sending commands to the PS/2 Controller (not to PS/2 devices).
</p>
<h2> <span class="mw-headline" id="PS.2F2_Controller_Commands"> PS/2 Controller Commands </span></h2>
<p>The PS/2 Controller accepts some commands and performs them. These commands should not be confused with bytes sent to a PS/2 device (e.g. keyboard, mouse).
</p><p>To send a command to the controller, simply write the command byte to IO port 0x64. If there is a "next byte" (the command is 2 bytes) then the next byte needs to be written to IO Port 0x60 after making sure that the controller is ready for it (by making sure bit 1 of the Status Register is clear). If there is a response byte, then the response byte needs to be read from IO Port 0x60 after making sure that it has arrived (by making sure bit 0 of the Status Register is set).
</p><p><br />
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1}}}">

<tr>
<th> Command Byte
</th>
<th> Meaning
</th>
<th> Response Byte
</th></tr>
<tr>
<td>0x20
</td>
<td>Read "byte 0" from internal RAM
</td>
<td>Controller Configuration Byte (see below)
</td></tr>
<tr>
<td>0x21 to 0x3F
</td>
<td>Read "byte N" from internal RAM (where 'N' is the command byte &amp; 0x1F)
</td>
<td>Unknown (only the first byte of internal RAM has a standard purpose)
</td></tr>
<tr>
<td>0x60
</td>
<td>Write next byte to "byte 0" of internal RAM (Controller Configuration Byte, see below)
</td>
<td>None
</td></tr>
<tr>
<td>0x61 to 0x7F
</td>
<td>Write next byte to "byte N" of internal RAM (where 'N' is the command byte &amp; 0x1F)
</td>
<td>None
</td></tr>
<tr>
<td>0xA7
</td>
<td>Disable second PS/2 port (only if 2 PS/2 ports supported)
</td>
<td>None
</td></tr>
<tr>
<td>0xA8
</td>
<td>Enable second PS/2 port (only if 2 PS/2 ports supported)
</td>
<td>None
</td></tr>
<tr>
<td>0xA9
</td>
<td>Test second PS/2 port (only if 2 PS/2 ports supported)
</td>
<td>0x00 test passed
<p>0x01 clock line stuck low
0x02 clock line stuck high
0x03 data line stuck low
0x04 data line stuck high
</p>
</td></tr>
<tr>
<td>0xAA
</td>
<td>Test PS/2 Controller
</td>
<td>0x55 test passed
<p>0xFC test failed
</p>
</td></tr>
<tr>
<td>0xAB
</td>
<td>Test first PS/2 port
</td>
<td>0x00 test passed
<p>0x01 clock line stuck low
0x02 clock line stuck high
0x03 data line stuck low
0x04 data line stuck high
</p>
</td></tr>
<tr>
<td>0xAC
</td>
<td>Diagnostic dump (real all bytes of internal RAM)
</td>
<td>Unknown
</td></tr>
<tr>
<td>0xAD
</td>
<td>Disable first PS/2 port
</td>
<td>None
</td></tr>
<tr>
<td>0xAE
</td>
<td>Enable first PS/2 port
</td>
<td>None
</td></tr>
<tr>
<td>0xC0
</td>
<td>Read controller input port
</td>
<td>Unknown (none of these bits have a standard/defined purpose)
</td></tr>
<tr>
<td>0xC1
</td>
<td>Copy bits 0 to 3 of input port to status bits 4 to 7
</td>
<td>None
</td></tr>
<tr>
<td>0xC2
</td>
<td>Copy bits 4 to 7 of input port to status bits 4 to 7
</td>
<td>None
</td></tr>
<tr>
<td>0xD0
</td>
<td>Read Controller Output Port
</td>
<td>Controller Output Port (see below)
</td></tr>
<tr>
<td>0xD1
</td>
<td>Write next byte to Controller Output Port (see below)
<p>Note: Check if output buffer is empty first
</p>
</td>
<td>None
</td></tr>
<tr>
<td>0xD2
</td>
<td>Write next byte to first PS/2 port output buffer (only if 2 PS/2 ports supported)
<p>(makes it look like the byte written was received from the first PS/2 port)
</p>
</td>
<td>None
</td></tr>
<tr>
<td>0xD3
</td>
<td>Write next byte to second PS/2 port output buffer (only if 2 PS/2 ports supported)
<p>(makes it look like the byte written was received from the second PS/2 port)
</p>
</td>
<td>None
</td></tr>
<tr>
<td>0xD4
</td>
<td>Write next byte to second PS/2 port input buffer (only if 2 PS/2 ports supported)
<p>(sends next byte to the second PS/2 port)
</p>
</td>
<td>None
</td></tr>
<tr>
<td>0xF0 to 0xFF
</td>
<td>Pulse output line low for 6 ms. Bits 0 to 3 are used as a mask (0 = pulse line, 1 = don't pulse line) and correspond to 4 different output lines.
<p>Note: Bit 0 corresponds to the "reset" line. The other output lines don't have a standard/defined purpose.
</p>
</td>
<td>None
</td></tr></table>
<p>Note: Command bytes not listed in the table above should be treated as either "chipset specific" or "unknown" and shouldn't be issued. Commands bytes that are marked as "only if 2 PS/2 ports supported" should also be treated as either "chipset specific" or "unknown" if the controller only supports one PS/2 port.
</p><p><br />
</p>
<h3> <span class="mw-headline" id="PS.2F2_Controller_Configuration_Byte"> PS/2 Controller Configuration Byte </span></h3>
<p>Commands 0x20 and 0x60 let you read and write the PS/2 Controller Configuration Byte. This configuration byte has the following format:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1}}}">

<tr>
<th> Bit
</th>
<th> Meaning
</th></tr>
<tr>
<td> 0
</td>
<td> First PS/2 port interrupt (1 = enabled, 0 = disabled)
</td></tr>
<tr>
<td> 1
</td>
<td> Second PS/2 port interrupt (1 = enabled, 0 = disabled, only if 2 PS/2 ports supported)
</td></tr>
<tr>
<td> 2
</td>
<td> System Flag (1 = system passed POST, 0 = your OS shouldn't be running)
</td></tr>
<tr>
<td> 3
</td>
<td> Should be zero
</td></tr>
<tr>
<td> 4
</td>
<td> First PS/2 port clock (1 = disabled, 0 = enabled)
</td></tr>
<tr>
<td> 5
</td>
<td> Second PS/2 port clock (1 = disabled, 0 = enabled, only if 2 PS/2 ports supported)
</td></tr>
<tr>
<td> 6
</td>
<td> First PS/2 port translation (1 = enabled, 0 = disabled)
</td></tr>
<tr>
<td> 7
</td>
<td> Must be zero
</td></tr>
</table>
<p>Note: Bits listed in the table above as "unknown" should be treated as either "chipset specific" or "unknown". Bits that are marked as "only if 2 PS/2 ports supported" should also be treated as either "chipset specific" or "unknown" if the controller only supports one PS/2 port.
</p><p><br />
</p>
<h3> <span class="mw-headline" id="PS.2F2_Controller_Output_Port"> PS/2 Controller Output Port </span></h3>
<p>Commands 0xD0 and 0xD1 let you read and write the PS/2 Controller Output Port. This output port has the following format:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1}}}">

<tr>
<th> Bit
</th>
<th> Meaning
</th></tr>
<tr>
<td> 0
</td>
<td> System reset (output)
<p><b>WARNING</b> always set to '1'. You need to pulse the reset line (e.g. using command 0xFE), and setting this bit to '0' can lock the computer up ("reset forever").
</p>
</td></tr>
<tr>
<td> 1
</td>
<td> A20 gate (output)
</td></tr>
<tr>
<td> 2
</td>
<td> Second PS/2 port clock (output, only if 2 PS/2 ports supported)
</td></tr>
<tr>
<td> 3
</td>
<td> Second PS/2 port data (output, only if 2 PS/2 ports supported)
</td></tr>
<tr>
<td> 4
</td>
<td> Output buffer full with byte from first PS/2 port (connected to IRQ1)
</td></tr>
<tr>
<td> 5
</td>
<td> Output buffer full with byte from second PS/2 port (connected to IRQ12, only if 2 PS/2 ports supported)
</td></tr>
<tr>
<td> 6
</td>
<td> First PS/2 port clock (output)
</td></tr>
<tr>
<td> 7
</td>
<td> First PS/2 port data (output)
</td></tr></table>
<p>Note: Bits that are marked in the table above as "only if 2 PS/2 ports supported" should be treated as either "chipset specific" or "unknown" if the controller only supports one PS/2 port.
</p><p><br />
</p>
<h2> <span class="mw-headline" id="Initialising_the_PS.2F2_Controller"> Initialising the PS/2 Controller </span></h2>
<p>Some people assume the PS/2 controller exists and was configured correctly by firmware. This approach can work, but isn't very robust and doesn't correctly support "less simple" scenarios. Examples of why this approach may not work well include:
</p>
<ul><li> Something (e.g. a Boot Manager) left the PS/2 Controller in a dodgy state
</li><li> The PS/2 Controller has hardware faults and your OS didn't do any testing
</li><li> There's a USB keyboard and a PS/2 mouse, and the BIOS didn't bother initialising the PS/2 controller because it was using USB Legacy Support and not using the mouse
</li><li> You want to reliably send data to the second PS/2 device on older hardware and have to know the second PS/2 port exists (see the warning for "Sending Bytes To The Second PS/2 Port" below).
</li></ul>
<p>The following steps are for "comprehensive PS/2 Controller initialisation". It may be excessive for your purposes, and a more limited version of it may be more suitable. However, it's easy enough to (selectively) remove steps from the following description.
</p>
<h4> <span class="mw-headline" id="Step_1:_Initialise_USB_Controllers"> Step 1: Initialise USB Controllers </span></h4>
<p>This doesn't have anything to do with the PS/2 Controller or PS/2 Devices, however if the system is using (typically limited/dodgy) USB Legacy Support it will interfere with PS/2 Controller initialisation. Therefore you need to initialise USB controllers and disable USB Legacy Support beforehand.
</p>
<h4> <span class="mw-headline" id="Step_2:_Determine_if_the_PS.2F2_Controller_Exists"> Step 2: Determine if the PS/2 Controller Exists </span></h4>
<p>Before you touch the PS/2 controller at all, you should determine if it actually exists. On some systems (e.g. 80x86 Apple machines) it doesn't exist and any attempt to touch it can result in a system crash. The correct way to do this is is with <a href="/ACPI" title="ACPI">ACPI</a>. More specifically, check bit 1 (value = 2, the "8042" flag) in the "IA PC Boot Architecture Flags" field at offset 109 in the Fixed ACPI Description Table (FADT). If this bit is clear then there is no PS/2 Controller to configure. Otherwise, if the bit is set or the system doesn't support ACPI (no ACPI tables and no FADT) then there is a PS/2 Controller.
</p>
<h4> <span class="mw-headline" id="Step_3:_Disable_Devices"> Step 3: Disable Devices </span></h4>
<p>So that any PS/2 devices can't send data at the wrong time and mess up your initialisation; start by sending a command 0xAD and command 0xA7 to the PS/2 controller. If the controller is a "single channel" device, it will ignore the "command 0xA7".
</p>
<h4> <span class="mw-headline" id="Step_4:_Flush_The_Output_Buffer"> Step 4: Flush The Output Buffer </span></h4>
<p>Sometimes (e.g. due to interrupt controller initialisation causing a lost IRQ) data can be stuck in the PS/2 controller's output buffer. To guard against this, now that the devices are disabled (and can't send more data to the output buffer) it can be a good idea to flush the controller's output buffer. There's 2 ways to do this - poll bit 0 of the Status Register (while reading from IO Port 0x60 if/when bit 0 becomes set), or read from IO Port 0x60 without testing bit 0. Either way should work (as you're discarding the data and don't care what it was).
</p>
<h4> <span class="mw-headline" id="Step_5:_Set_the_Controller_Configuration_Byte"> Step 5: Set the Controller Configuration Byte  </span></h4>
<p>Because some bits of the Controller Configuration Byte are "unknown", this means reading the old value (command 0x20), changing some bits, then writing the modified value back (command 0x60). You want to disable all IRQs and disable translation (clear bits 0, 1 and 6).
</p><p>While you've got the Configuration Byte, test if bit 5 was set. If it was clear then you know it can't be a "dual channel" PS/2 controller (because the second PS/2 port should be disabled).
</p>
<h4> <span class="mw-headline" id="Step_6:_Perform_Controller_Self_Test"> Step 6: Perform Controller Self Test  </span></h4>
<p>To test the PS/2 controller, send command 0xAA to it. Then wait for its response and check that it replied with 0x55.
</p>
<h4> <span class="mw-headline" id="Step_7:_Determine_If_There_Are_2_Channels"> Step 7: Determine If There Are 2 Channels  </span></h4>
<p>If you know it's a single channel controller (from Step 5) then skip this step. Otherwise, send a command 0xA8 to enable the second PS/2 port and read the Controller Configuration Byte again. Now bit 5 of the Controller Configuration Byte should be clear - if it's set then you know it can't be a "dual channel" PS/2 controller (because the second PS/2 port should be enabled). If it is a dual channel device, send a command 0xA7 to disable the second PS/2 port again.
</p>
<h4> <span class="mw-headline" id="Step_8:_Perform_Interface_Tests"> Step 8: Perform Interface Tests  </span></h4>
<p>This step tests the PS/2 ports. Use command 0xAB to test the first PS/2 port, then check the result. Then (if it's a "dual channel" controller) use command 0xA9 to test the second PS/2 port, then check the result.
</p><p>At this stage, check to see how many PS/2 ports are left. If there aren't any that work you can just give up (display some errors and terminate the PS/2 Controller driver). <i>Note: If one of the PS/2 ports on a dual PS/2 controller fails, then you can still keep going and use/support the other PS/2 port.</i>
</p>
<h4> <span class="mw-headline" id="Step_9:_Enable_Devices"> Step 9: Enable Devices  </span></h4>
<p>Enable any PS/2 port that exists and works using command 0xAE (for the first port) and command 0xA8 (for the second port). If you're using IRQs (recommended), also enable interrupts for any (usable) PS/2 ports in the Controller Configuration Byte (set bit 0 for the first PS/2 port, and/or bit 1 for the second PS/2 port, then set it with command 0x60).
</p>
<h4> <span class="mw-headline" id="Step_10:_Reset_Devices"> Step 10: Reset Devices  </span></h4>
<p>All PS/2 devices should support the "reset" command (which is a command for the device, and not a command for the PS/2 Controller). To send the reset, just send the byte 0xFF to each (usable) device. The device/s will respond with 0xFA (success) or 0xFC (failure), or won't respond at all (no device present). If your code supports "hot-plug PS/2 devices" (see later), then you can assume each device is "not present" and let the hot-plug code figure out that the device is present if/when 0xFA or 0xFC is received on a PS/2 port.
</p><p><b>TODO</b>: Potential wiki error, the 0xFF reset device command seems to respond 0xAA and then 0xFA on self-test success, and <a href="/PS/2_Keyboard" title="PS/2 Keyboard">PS/2_Keyboard</a> agrees. --<a href="/User:Sortie" title="User:Sortie">Sortie</a> 14:15, 27 April 2015 (CDT)
</p>
<h2> <span class="mw-headline" id="Detecting_PS.2F2_Device_Types"> Detecting PS/2 Device Types </span></h2>
<p>All PS/2 devices should support the "identify" command and the "disable scanning" command (which are commands for the device, and not commands for the PS/2 Controller). The device should respond to the "identify" command by sending a sequence of none, one or two identification bytes. However, if you just send the "identify" command you can't prevent the response from the "identify" command from being mixed up with keyboard/mouse data. To fix this problem, you need to send the "disable scanning" command first. Disabling scanning means that the device ignores the user (e.g. keyboards ignore keypresses, mice ignore mouse movement and button presses, etc) and won't send data to mess your device identification code up.
</p><p>The full sequence is:
</p>
<ul><li> Send the "disable scanning" command 0xF5 to the device
</li><li> Wait for device to send "ACK" back (0xFA)
</li><li> Send the "identify" command 0xF2 to the device
</li><li> Wait for device to send "ACK" back (0xFA)
</li><li> Wait for device to send up to 2 bytes of reply, with a time-out to determine when it's finished (e.g. in case it only sends 1 byte)
</li></ul>
<p>A partial list of responses includes:
</p>
<table border="2" cellpadding="4" cellspacing="0" style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; &#123;&#123;&#123;1}}}">

<tr>
<th> Byte/s
</th>
<th> Device Type
</th></tr>
<tr>
<td> None
</td>
<td> Ancient AT keyboard with translation enabled in the PS/Controller (not possible for the second PS/2 port)
</td></tr>
<tr>
<td> 0x00
</td>
<td> Standard PS/2 mouse
</td></tr>
<tr>
<td> 0x03
</td>
<td> Mouse with scroll wheel
</td></tr>
<tr>
<td> 0x04
</td>
<td> 5-button mouse
</td></tr>
<tr>
<td> 0xAB, 0x41 or 0xAB, 0xC1
</td>
<td> MF2 keyboard with translation enabled in the PS/Controller (not possible for the second PS/2 port)
</td></tr>
<tr>
<td> 0xAB, 0x83
</td>
<td> MF2 keyboard
</td></tr></table>
<p>Note: If anyone sees any other responses please add to the list above!
</p><p>Once your PS/2 Controller driver knows what types of PS/2 devices are present, it can start suitable device drivers for those devices. Don't forget that we've left devices in a "scanning disabled" state.
</p><p><br />
</p>
<h2> <span class="mw-headline" id="Hot_Plug_PS.2F2_Devices"> Hot Plug PS/2 Devices </span></h2>
<p><b>WARNING:</b> PS/2 was never intentionally designed to support hot-plug. Usually it is fine as most PS/2 controllers have reasonably robust IO lines, however some PS/2 controllers (mostly those in old chipsets) may potentially be damaged.
</p><p>Despite the warning, most OSs (Windows, Linux, etc) do support hot-plug PS/2. It is also relied on by old "mechanical switch" KVMs (which allow the same PS/2 devices to be shared by multiple computers by effectively disconnecting the device from one computer and connecting it to the next).
</p><p>When a PS/2 device is removed the PS/2 controller won't know. To work around this, when no data has been received from the device for some length of time (e.g. 2 seconds), an OS can periodically test for the presence of the device by sending an "echo" command to the device and checking for a reply. If the device doesn't respond, then assume the device has been unplugged.
</p><p>When a PS/2 device is first powered up (e.g. when it is plugged in to a PS/2 port), the device should perform its Basic Assurance Test and then attempt to send a "BAT completion code". This means that software (e.g. an OS) can automatically detect when a PS/2 device has been inserted. <i>Note: If a device is removed and then another device (or the same device) is plugged in quickly enough, the software may not have had time to detect the removal.</i>
</p><p>When software detects that a device was plugged in it can determine the type of device (see above). If the device was the same type as before software can re-configure it so that the device is in the same state as it was before removal. This means that (for example) someone using an old "mechanical switch" KVMs doesn't lose state (things like keyboard LEDs, typematic rate, etc) when switching between computers. If the device is not the same as before or there was no previously connected device, then software may need to start a new device driver (and terminate the old device driver, if any).
</p><p><br />
</p>
<h2> <span class="mw-headline" id="Sending_Bytes_To_Device.2Fs"> Sending Bytes To Device/s </span></h2>
<p>Unfortunately, the PS/2 Controller does not support interrupt driven transmission (e.g. you can't have a queue of bytes waiting to be sent and then send each byte from inside a "transmitter empty" IRQ handler). Fortunately very little data needs to be sent to typical PS/2 devices and polling suffices.
</p>
<h3> <span class="mw-headline" id="First_PS.2F2_Port"> First PS/2 Port </span></h3>
<p>To send data to the first PS/2 Port:
</p>
<ul><li> Set up some sort of timer or counter to use as a time-out
</li><li> Poll bit 1 of the Status Register ("Input buffer empty/full") until it becomes clear, or until your time-out expires
</li><li> If the time-out expired, return an error
</li><li> Otherwise, write the data to the Data Port (IO port 0x60)
</li></ul>
<h3> <span class="mw-headline" id="Second_PS.2F2_Port"> Second PS/2 Port </span></h3>
<p>Sending data to the second PS/2 port is a little more complicated, as you need to send a command to the PS/2 controller to tell it that you want to talk to the second PS/2 port instead of the first PS/2 port. To send data to the second PS/2 Port:
</p>
<ul><li> Write the command 0xD4 to IO Port 0x64
</li><li> Set up some sort of timer or counter to use as a time-out
</li><li> Poll bit 1 of the Status Register ("Input buffer empty/full") until it becomes clear, or until your time-out expires
</li><li> If the time-out expired, return an error
</li><li> Otherwise, write the data to the Data Port (IO port 0x60)
</li></ul>
<p><b>WARNING:</b> If the PS/2 controller is an (older) "single PS/2 device only" controller, if you attempt to send a byte to the second PS/2 port the controller will ignore the command 0xD4 you send to IO Port 0x64, and therefore the byte you send will actually be sent to the first PS/2 device. This means that (if you support older hardware) to reliably send data to the second device you have to know that the PS/2 Controller actually does have a second PS/2 port.
</p><p><br />
</p>
<h2> <span class="mw-headline" id="Recieving_Bytes_From_Device.2Fs"> Recieving Bytes From Device/s </span></h2>
<p>There are 2 ways to receive bytes from device/s: polling, and using IRQ.
</p>
<h3> <span class="mw-headline" id="Polling"> Polling </span></h3>
<p>To poll, wait until bit 0 of the Status Register becomes set, then read the received byte of data from IO Port 0x60.
</p><p>There are 2 major problems with polling. The first problem is that (like all polling) it wastes a lot of CPU time for nothing. The second problem is that if the PS/2 controller supports two PS/2 devices there's no way to reliably determine which device sent the byte that you've received, unless one of them is disabled and unable to send data.
</p><p>Note: if the PS/2 controller uses bit 5 of the Status Register as a "second PS/2 port output buffer full" flag, you'd still have problems trying to determine which device sent a byte of data you've received without race conditions. For example, there may be data from the second PS/2 device waiting for you when you check the flag, but before you read from IO Port 0x60 data from the first PS/2 device might arrive and you might read data from the first PS/2 device when you think you're reading data from the second PS/2 device. Of course there's also no easy way to know if the PS/2 controller does use bit 5 of the Status Register as a "second PS/2 port output buffer full" flag.
</p>
<h3> <span class="mw-headline" id="Interrupts"> Interrupts </span></h3>
<p>Using interrupts is actually easy. When IRQ1 occurs you just read from IO Port 0x60 (there is no need to check bit 0 in the Status Register first), send the EOI to the interrupt controller and return from the interrupt handler. You know that the data came from the first PS/2 device because you received an IRQ1.
</p><p>When IRQ12 occurs you just read from IO Port 0x60 (there is no need to check bit 0 in the Status Register first), send the EOI to the interrupt controller/s and return from the interrupt handler. You know that the data came from the second PS/2 device because you received an IRQ12.
</p><p>Unfortunately there is one problem to worry about. If you send a command to the PS/2 controller that involves a response, the PS/2 controller will put a "response byte" into the buffer and won't generate any IRQ (because the byte didn't come from any PS/2 device). In this case you have to poll, and if you have to poll you can't determine where the byte came from unless all PS/2 devices are disabled. Fortunately you should never need to send a command to the PS/2 controller itself after initialisation (and you can disable both PS/2 devices where necessary during initialisation).
</p><p><br />
</p>
<h2> <span class="mw-headline" id="CPU_Reset"> CPU Reset </span></h2>
<p>To trigger a CPU Reset, regardless of what state the CPU is currently in, write the value 0xFE to the Output port.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="asm source-asm"><pre class="de1"> <span class="co1">;Wait for a empty Input Buffer</span>
 wait1<span class="sy0">:</span>
 <span class="kw1">in</span>   <span class="kw3">al</span><span class="sy0">,</span> <span class="nu0">0x64</span>
 <span class="kw1">test</span> <span class="kw3">al</span><span class="sy0">,</span> <span class="nu0">00000010b</span>
 <span class="kw1">jne</span>  wait1
&#160;
 <span class="co1">;Send 0xFE to the keyboard controller.</span>
 <span class="kw1">mov</span>  <span class="kw3">al</span><span class="sy0">,</span> <span class="nu0">0xFE</span>
 <span class="kw1">out</span>  <span class="nu0">0x64</span><span class="sy0">,</span> <span class="kw3">al</span></pre></div></div>
<h2> <span class="mw-headline" id="See_Also">See Also</span></h2>
<ul><li><a href="/PS/2" title="PS/2">PS/2</a>
</li><li><a href="/PL050_PS/2_Controller" title="PL050 PS/2 Controller"> PL050 PS/2 Controller (ARM)</a>
</li><li><a href="/PS/2_Keyboard" title="PS/2 Keyboard">PS/2 Keyboard</a>
</li><li><a href="/PS/2_Mouse" title="PS/2 Mouse">PS/2 Mouse</a>
</li></ul>
<h3> <span class="mw-headline" id="Threads">Threads</span></h3>
<ul><li><a href="http://forum.osdev.org/viewtopic.php?p=69151#p69151" class="extiw" title="post:69151">PS/2 controller initialisation</a>
</li></ul>
<h3> <span class="mw-headline" id="External_Links">External Links</span></h3>
<ul><li> <a rel="nofollow" class="external text" href="http://www.diakom.ru/el/elfirms/datashts/Smsc/42w11.pdf">SMS "8042" Datasheet</a>
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 235/1000000
Post-expand include size: 972/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:3160-0!*!0!!en!2!* and timestamp 20160926022800 -->
</div>				<!-- /bodycontent -->
								<!-- printfooter -->
				<div class="printfooter">
				Retrieved from "<a href="http://wiki.osdev.org/index.php?title=%228042%22_PS/2_Controller&amp;oldid=17935">http://wiki.osdev.org/index.php?title=%228042%22_PS/2_Controller&amp;oldid=17935</a>"				</div>
				<!-- /printfooter -->
												<!-- catlinks -->
				<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="/Category:X86" title="Category:X86">X86</a></li><li><a href="/Category:Common_Devices" title="Category:Common Devices">Common Devices</a></li></ul></div></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
				<!-- debughtml -->
								<!-- /debughtml -->
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="mw-head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Personal tools</h5>
	<ul>
		<li id="pt-login"><a href="/index.php?title=Special:UserLogin&amp;returnto=%228042%22_PS%2F2_Controller" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
	</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="/%228042%22_PS/2_Controller"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk"><span><a href="/Talk:%228042%22_PS/2_Controller"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
		<h5><span>Variants</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="/%228042%22_PS/2_Controller" >Read</a></span></li>
					<li id="ca-viewsource"><span><a href="/index.php?title=%228042%22_PS/2_Controller&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="/index.php?title=%228042%22_PS/2_Controller&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
	<form action="/index.php" id="searchform">
		<input type='hidden' name="title" value="Special:Search"/>
				<input type="search" name="search" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput" />		<input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" />		<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" />			</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url(/skins/common/images/osdev.png);" href="/Main_Page"  title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" id='p-navigation'>
	<h5>Navigation</h5>
	<div class="body">
		<ul>
			<li id="n-mainpage"><a href="/Main_Page" title="Visit the main page [z]" accesskey="z">Main Page</a></li>
			<li id="n-portal"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things">Forums</a></li>
			<li id="n-FAQ"><a href="/Category:FAQ">FAQ</a></li>
			<li id="n-OS-Projects"><a href="/Projects">OS Projects</a></li>
			<li id="n-randompage"><a href="/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
		</ul>
	</div>
</div>

<!-- /navigation -->

<!-- about -->
<div class="portal" id='p-about'>
	<h5>About</h5>
	<div class="body">
		<ul>
			<li id="n-This-site"><a href="/OSDevWiki:About">This site</a></li>
			<li id="n-Joining"><a href="/OSDevWiki:Joining">Joining</a></li>
			<li id="n-Editing-help"><a href="/OSDevWiki:Editing">Editing help</a></li>
			<li id="n-recentchanges"><a href="/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
		</ul>
	</div>
</div>

<!-- /about -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id='p-tb'>
	<h5>Toolbox</h5>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="/Special:WhatLinksHere/%228042%22_PS/2_Controller" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="/Special:RecentChangesLinked/%228042%22_PS/2_Controller" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li><a href="/index.php?title=%228042%22_PS/2_Controller&amp;printable=yes" rel="alternate">Printable version</a></li>
			<li id="t-permalink"><a href="/index.php?title=%228042%22_PS/2_Controller&amp;oldid=17935" title="Permanent link to this revision of the page">Permanent link</a></li>
		</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->
<div class="portal" id='p-lang'>
	<h5>In other languages</h5>
	<div class="body">
		<ul>
			<li class="interwiki-de"><a href="http://www.lowlevel.eu/wiki/Keyboard_Controller" title="Keyboard Controller">Deutsch</a></li>
		</ul>
	</div>
</div>

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 27 April 2015, at 14:19.</li>
											<li id="footer-info-viewcount">This page has been accessed 49,372 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="/OSDev_Wiki:Privacy_policy" title="OSDev Wiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/OSDev_Wiki:About" title="OSDev Wiki:About">About OSDev Wiki</a></li>
											<li id="footer-places-disclaimer"><a href="/OSDev_Wiki:General_disclaimer" title="OSDev Wiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		<!-- fixalpha -->
		<script type="text/javascript"> if ( window.isMSIE55 ) fixalpha(); </script>
		<!-- /fixalpha -->
		<script src="/load.php?debug=false&amp;lang=en&amp;modules=skins.vector&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
}
</script>
<script src="/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,
	"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: wikidb:resourceloader:filter:minify-js:4:19a4b18a9ac79a6b8c60b24af4668814 */
}
</script><!-- Served in 0.138 secs. -->
	</body>
</html>
